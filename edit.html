<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta name="color-scheme" content="light" />
    <title>Manage Flashcards</title>
    <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
    <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;500;600;700&amp;display=swap" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet" />
    <style>
        .material-symbols-outlined {
            font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24;
        }
    </style>
    <style>
        html {
            color-scheme: light;
        }
    </style>
    <script id="tailwind-config">
        tailwind.config = {
            darkMode: "class",
            theme: {
                extend: {
                    colors: {
                        "primary": "#007AFF",
                        "background-light": "#F9F9F9",
                        "background-dark": "#101622",
                        "neutral-gray": "#8E8E93",
                        "destructive-red": "#FF3B30",
                        "near-black": "#1C1C1E"
                    },
                    fontFamily: {
                        "display": ["Lexend", "sans-serif"]
                    },
                    borderRadius: {
                        "DEFAULT": "0.5rem",
                        "lg": "0.75rem",
                        "xl": "1rem",
                        "full": "9999px"
                    },
                },
            },
        }
    </script>
    <style>
        body {
            min-height: max(884px, 100dvh);
        }
        
        .loading-overlay {
            position: fixed;
            inset: 0;
            z-index: 50;
            display: none;
            background: rgba(255, 255, 255, 0.6);
        }
        
        .loading-overlay.is-active {
            display: grid;
            place-items: center;
        }
        
        .loading-dots {
            display: flex;
            gap: 8px;
            color: #8E8E93;
        }
        
        .loading-dots span {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            opacity: 0.5;
            animation: dotPulse 1000ms infinite ease-in-out;
        }
        
        .loading-dots span:nth-child(2) {
            animation-delay: 150ms;
        }
        
        .loading-dots span:nth-child(3) {
            animation-delay: 300ms;
        }
        
        @keyframes dotPulse {
            0% {
                transform: scale(1);
                opacity: 0.35;
            }
            50% {
                transform: scale(1.25);
                opacity: 1;
            }
            100% {
                transform: scale(1);
                opacity: 0.35;
            }
        }
        
        .row-enter {
            animation: slideDown 360ms ease-out both;
            will-change: transform, opacity;
        }
        
        @keyframes slideDown {
            0% {
                transform: translateY(-6px);
                opacity: 0;
            }
            100% {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .row-processing {
            background: rgba(245, 158, 11, 0.16);
            border: 1px solid rgba(245, 158, 11, 0.45);
        }
    </style>
</head>

<body class="font-display bg-background-light dark:bg-background-dark">
    <div class="relative flex min-h-screen w-full flex-col">
        <header class="sticky top-0 z-10 flex items-center justify-between border-b border-gray-200/80 bg-background-light/80 px-4 py-3 backdrop-blur-sm dark:border-gray-800/80 dark:bg-background-dark/80">
            <div class="flex items-center gap-2">
                <button id="backBtn" class="flex size-10 items-center justify-center text-near-black dark:text-white">
<span class="material-symbols-outlined text-2xl">arrow_back_ios_new</span>
</button>
            </div>
            <h1 id="deckTitle" class="text-lg font-semibold text-near-black dark:text-white">Deck</h1>
            <div class="w-10"></div>
        </header>
        <main class="flex-1 px-4 py-6 pb-24">
            <div class="mb-4 flex items-center gap-3">
                <label for="deckSelectEdit" class="text-sm font-medium text-near-black dark:text-white">Deck</label>
                <select id="deckSelectEdit" class="flex-1 rounded-lg border border-gray-300 bg-white px-3 py-2 text-sm dark:border-gray-700 dark:bg-gray-800/60 dark:text-white"></select>
            </div>
            <div class="mb-4 flex items-center gap-3">
                <input id="renameInput" type="text" class="flex-1 rounded-lg border border-gray-300 bg-white px-3 py-2 text-sm dark:border-gray-700 dark:bg-gray-800/60 dark:text-white" placeholder="New deck name" />
                <button id="renameBtn" class="h-10 rounded-lg bg-primary px-4 text-white">Rename</button>
            </div>
            <div class="mb-6">
                <button id="deleteDeckBtn" class="h-10 w-full rounded-lg border border-destructive-red text-destructive-red">Delete deck</button>
            </div>
            <div id="cardList" class="space-y-3"></div>
        </main>
        <div id="globalLoader" class="loading-overlay" aria-hidden="true">
            <div class="loading-dots"><span></span><span></span><span></span></div>
        </div>
        <div id="editModal" class="fixed inset-0 z-40 hidden items-center justify-center bg-black/40 p-4">
            <div class="w-full max-w-sm rounded-xl bg-background-light dark:bg-background-dark p-4 shadow-xl">
                <h2 class="text-base font-semibold text-near-black dark:text-white">Edit Card</h2>
                <div class="mt-3 space-y-3">
                    <input id="editEn" type="text" class="w-full rounded-lg border border-gray-300 bg-white px-3 py-2 text-sm dark:border-gray-700 dark:bg-gray-800/60" placeholder="English" />
                    <input id="editDe" type="text" class="w-full rounded-lg border border-gray-300 bg-white px-3 py-2 text-sm dark:border-gray-700 dark:bg-gray-800/60" placeholder="German" />
                </div>
                <div class="mt-4 grid grid-cols-2 gap-3">
                    <button id="editCancel" class="h-10 rounded-lg border border-gray-300 bg-white text-near-black dark:border-gray-700 dark:bg-gray-800/60 dark:text-white">Cancel</button>
                    <button id="editSave" class="h-10 rounded-lg bg-primary text-white">Save</button>
                </div>
            </div>
        </div>
        <div class="fixed bottom-6 right-6 z-20">
            <button id="addBtn" class="flex h-14 w-14 items-center justify-center rounded-full bg-primary text-white shadow-lg transition-transform hover:scale-105 active:scale-95">
                <span class="material-symbols-outlined text-3xl">add</span>
            </button>
        </div>
    </div>

</body>

<script>
    const backBtn = document.getElementById('backBtn');
    const deckTitle = document.getElementById('deckTitle');
    const cardList = document.getElementById('cardList');
    const globalLoader = document.getElementById('globalLoader');
    const editModal = document.getElementById('editModal');
    const editEn = document.getElementById('editEn');
    const editDe = document.getElementById('editDe');
    const editCancel = document.getElementById('editCancel');
    const editSave = document.getElementById('editSave');
    const addBtn = document.getElementById('addBtn');
    const params = new URLSearchParams(location.search);
    const deckSelectEdit = document.getElementById('deckSelectEdit');
    const renameInput = document.getElementById('renameInput');
    const renameBtn = document.getElementById('renameBtn');
    const deleteDeckBtn = document.getElementById('deleteDeckBtn');
    const audioPlayer = new Audio();
    const audioCache = new Map();
    const MAX_CACHE_SIZE = 50;
    const processingWords = new Set();
    let deck = params.get('deck') || '';
    if (deck) deckTitle.textContent = deck;
    if (renameInput) renameInput.value = deck || '';
    let cards = [];
    let editingIndex = -1;
    let didInitialAnimation = false;

    function showLoader() {
        if (globalLoader) globalLoader.classList.add('is-active');
    }

    function hideLoader() {
        if (globalLoader) globalLoader.classList.remove('is-active');
    }
    backBtn.addEventListener('click', () => {
        location.href = '/';
    });
    async function loadCards() {
        showLoader();
        try {
            const r = await fetch(`/cards?deck=${encodeURIComponent(deck)}`);
            const data = r.ok ? await r.json() : [];
            cards = Array.isArray(data) ? data : [];
            renderList();
            hydrateAudioFromLocalStorage();
            if (deck) preloadDeckAudio();
            hideLoader();
        } catch {
            cards = [];
            renderList();
            hideLoader();
        }
    }

    function renderList() {
        cardList.innerHTML = '';
        if (!cards.length) {
            cardList.innerHTML = '<div class="text-center text-neutral-gray">No cards</div>';
            return;
        }
        cards.forEach((c, i) => {
            const row = document.createElement('div');
            row.className = 'flex items-center gap-4 rounded-lg bg-white p-4 shadow-sm dark:bg-gray-800/50' + (didInitialAnimation ? '' : ' row-enter');
            if (!didInitialAnimation) row.style.animationDelay = `${i*40}ms`;
            if (processingWords.has(c.de)) row.classList.add('row-processing');
            const left = document.createElement('div');
            left.className = 'flex flex-1 flex-col justify-center';
            const de = document.createElement('p');
            de.className = 'text-base font-medium text-near-black dark:text-white';
            de.textContent = c.de;
            const en = document.createElement('p');
            en.className = 'text-sm text-neutral-gray dark:text-gray-400';
            en.textContent = c.en;
            left.appendChild(de);
            left.appendChild(en);
            const right = document.createElement('div');
            right.className = 'flex shrink-0 items-center gap-2';
            const btnEdit = document.createElement('button');
            btnEdit.className = 'flex size-10 items-center justify-center rounded-full text-neutral-gray transition-colors hover:bg-gray-100 dark:text-gray-400 dark:hover:bg-gray-700';
            btnEdit.innerHTML = '<span class="material-symbols-outlined text-xl">edit</span>';
            btnEdit.addEventListener('click', () => openEdit(i));
            const btnReload = document.createElement('button');
            btnReload.className = 'flex size-10 items-center justify-center rounded-full text-neutral-gray transition-colors hover:bg-gray-100 dark:text-gray-400 dark:hover:bg-gray-700';
            btnReload.innerHTML = '<span class="material-symbols-outlined text-xl">cached</span>';
            btnReload.title = 'Reload audio';
            btnReload.addEventListener('click', () => reloadAudio(i));
            const btnDelete = document.createElement('button');
            btnDelete.className = 'flex size-10 items-center justify-center rounded-full text-destructive-red transition-colors hover:bg-red-50 dark:hover:bg-red-500/10';
            btnDelete.innerHTML = '<span class="material-symbols-outlined text-xl">delete</span>';
            btnDelete.addEventListener('click', () => deleteCard(i));
            row.appendChild(left);
            row.appendChild(right);
            right.appendChild(btnEdit);
            right.appendChild(btnReload);
            right.appendChild(btnDelete);
            row.addEventListener('click', (e) => {
                if (e.target.closest('button')) return;
                const t = (c.de || '').trim();
                if (t) speak(t);
            });
            cardList.appendChild(row);
        });
        didInitialAnimation = true;
    }

    function openEdit(i) {
        editingIndex = i;
        const c = cards[i];
        editEn.value = c.en || '';
        editDe.value = c.de || '';
        editModal.classList.remove('hidden');
    }

    function closeEdit() {
        editingIndex = -1;
        editModal.classList.add('hidden');
    }
    editCancel.addEventListener('click', closeEdit);
    editModal.addEventListener('click', (e) => {
        if (e.target === editModal) closeEdit();
    });
    editSave.addEventListener('click', async() => {
        const en = (editEn.value || '').trim();
        const de = (editDe.value || '').trim();
        if (!en || !de) return;
        if (editingIndex === -1) cards.push({ en, de });
        else cards[editingIndex] = { en, de };
        closeEdit();
        processingWords.add(de);
        renderList();
        const p1 = saveDeckSilent();
        const p2 = preloadAudioForWord(de);
        Promise.allSettled([p1, p2]).then(() => {
            processingWords.delete(de);
            renderList();
        });
    });
    async function saveDeck() {
        showLoader();
        try {
            const content = cards.map(r => `${r.en},${r.de}`).join('\n');
            const resp = await fetch('/deck/update', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    name: deck,
                    content
                })
            });
            await resp.json();
            await loadCards();
        } catch {
            hideLoader();
        } finally {
            hideLoader();
        }
    }
    async function saveDeckSilent() {
        try {
            const content = cards.map(r => `${r.en},${r.de}`).join('\n');
            return fetch('/deck/update', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: deck, content })
            }).then(r => r.json()).catch(() => ({}));
        } catch {
            return Promise.resolve({});
        }
    }
    async function deleteCard(i) {
        cards.splice(i, 1);
        await saveDeck();
    }
    async function reloadAudio(i) {
        const text = (cards[i] && cards[i].de || '').trim();
        if (!text) return;
        showLoader();
        try {
            await fetch('/audio/rebuild', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    text,
                    lang: 'de'
                })
            }).then(r => r.json()).catch(() => {});
        } catch {} finally {
            hideLoader();
        }
    }
    addBtn.addEventListener('click', () => {
        editingIndex = -1;
        editEn.value = '';
        editDe.value = '';
        editModal.classList.remove('hidden');
    });
    loadCards();

    async function loadDecks() {
        showLoader();
        try {
            const resp = await fetch('/decks');
            const list = await resp.json();
            const items = Array.isArray(list) ? list : [];
            deckSelectEdit.innerHTML = '';
            const placeholder = document.createElement('option');
            placeholder.value = '';
            placeholder.textContent = 'Select deck';
            placeholder.disabled = false;
            deckSelectEdit.appendChild(placeholder);
            items.forEach(d => {
                const opt = document.createElement('option');
                opt.value = d.name;
                opt.textContent = d.name;
                deckSelectEdit.appendChild(opt);
            });
            if (deck) {
                deckSelectEdit.value = deck;
            }
            deckSelectEdit.addEventListener('change', async(e) => {
                deck = e.target.value || '';
                deckTitle.textContent = deck || 'Deck';
                cards = [];
                cardList.innerHTML = '';
                if (renameInput) renameInput.value = deck || '';
                if (deck) {
                    await loadCards();
                }
            });
            hideLoader();
        } catch {
            hideLoader();
        }
    }

    function sanitizeName(n) {
        return (n || '').trim().replace(/[^a-zA-Z0-9_\-]+/g, '_').substring(0, 50)
    }
    if (renameBtn) renameBtn.addEventListener('click', async() => {
        const newRaw = (renameInput && renameInput.value || '').trim();
        const newName = sanitizeName(newRaw);
        if (!deck) {
            alert('Please select a deck.');
            return
        }
        if (!newName) {
            alert('Please enter a new name.');
            return
        }
        if (newName === deck) {
            alert('New name must be different.');
            return
        }
        renameBtn.disabled = true;
        renameBtn.textContent = 'Renaming...';
        try {
            const resp = await fetch('/deck/rename', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    old_name: deck,
                    new_name: newName
                })
            });
            const out = await resp.json().catch(() => ({
                ok: false
            }));
            if (!resp.ok || !out.ok) throw new Error(out.detail || 'Failed to rename deck');
            deck = newName;
            deckTitle.textContent = deck;
            await loadDecks();
            deckSelectEdit.value = deck;
            await loadCards();
            renameBtn.textContent = 'Renamed';
            setTimeout(() => {
                renameBtn.disabled = false;
                renameBtn.textContent = 'Rename'
            }, 800)
        } catch (e) {
            alert(String(e.message || e));
            renameBtn.disabled = false;
            renameBtn.textContent = 'Rename'
        }
    });
    if (deleteDeckBtn) deleteDeckBtn.addEventListener('click', async() => {
        if (!deck) {
            alert('Please select a deck.');
            return
        }
        deleteDeckBtn.disabled = true;
        deleteDeckBtn.textContent = 'Deleting...';
        try {
            const resp = await fetch('/deck/delete', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    name: deck
                })
            });
            const out = await resp.json().catch(() => ({
                ok: false
            }));
            if (!resp.ok || !out.ok) throw new Error(out.detail || 'Failed to delete deck');
            deleteDeckBtn.textContent = 'Deleted';
            setTimeout(() => {
                location.href = '/'
            }, 600)
        } catch (e) {
            alert(String(e.message || e));
            deleteDeckBtn.disabled = false;
            deleteDeckBtn.textContent = 'Delete deck'
        }
    });

    loadDecks();

    async function speak(text) {
        if (!text) return;
        try {
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
            const cacheKey = `audio:de:${text}`;
            const stored = localStorage.getItem(cacheKey);
            if (stored && !audioCache.has(text)) {
                audioCache.set(text, stored);
            }
            if (audioCache.has(text)) {
                audioPlayer.src = audioCache.get(text);
                await audioPlayer.play();
                return;
            }
            const resp = await fetch(`/tts?text=${encodeURIComponent(text)}&lang=de`);
            if (resp.ok) {
                const blob = await resp.blob();
                const url = URL.createObjectURL(blob);
                audioCache.set(text, url);
                audioPlayer.src = url;
                await audioPlayer.play();
            }
        } catch {}
    }

    function cleanupAudioCache() {
        if (audioCache.size > MAX_CACHE_SIZE) {
            const entries = Array.from(audioCache.entries());
            const toRemove = entries.slice(0, entries.length - MAX_CACHE_SIZE);
            toRemove.forEach(([key, url]) => {
                if (typeof url === 'string' && url.startsWith('blob:')) {
                    try { URL.revokeObjectURL(url); } catch {}
                }
                audioCache.delete(key);
            });
        }
    }

    function hydrateAudioFromLocalStorage() {
        cards.forEach(c => {
            const key = `audio:de:${c.de}`;
            const val = localStorage.getItem(key);
            if (val) audioCache.set(c.de, val);
        });
    }

    async function preloadDeckAudio() {
        if (!deck) return;
        try {
            const resp = await fetch(`/preload_deck_audio?deck=${encodeURIComponent(deck)}`);
            if (!resp.ok) return;
            const data = await resp.json().catch(() => ({}));
            const entries = Object.entries((data && data.audio_urls) || {});
            const tasks = entries.map(([text, url]) => fetchAudioAndCache(text, url));
            await Promise.allSettled(tasks);
        } catch {}
    }

    function preloadAudioForWord(text) {
        if (!text) return Promise.resolve();
        const url = `/tts?text=${encodeURIComponent(text)}&lang=de`;
        return fetchAudioAndCache(text, url);
    }

    async function fetchAudioAndCache(text, url) {
        const cacheKey = `audio:de:${text}`;
        if (audioCache.has(text) || localStorage.getItem(cacheKey)) return;
        try {
            const response = await fetch(url);
            if (!response.ok) return;
            const blob = await response.blob();
            const objUrl = URL.createObjectURL(blob);
            cleanupAudioCache();
            audioCache.set(text, objUrl);
            try {
                const base64 = await blobToBase64(blob);
                localStorage.setItem(cacheKey, base64);
            } catch {}
        } catch {}
    }

    function blobToBase64(blob) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(blob);
        });
    }
</script>

</html>