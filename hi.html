<!DOCTYPE html>

<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta name="theme-color" content="#ffffff" />
    <meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: dark)" />
    <meta name="msapplication-navbutton-color" content="#ffffff" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <title>Flashcard Deck Screen</title>
    <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
    <link href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;500;600;700&amp;display=swap" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet" />
    <script id="tailwind-config">
        tailwind.config = {
            darkMode: "class",
            theme: {
                extend: {
                    colors: {
                        "primary": "#007AFF",
                        "background-light": "#F9F9F9",
                        "background-dark": "#101922",
                        "card-light": "#FFFFFF",
                        "card-dark": "#19242E",
                        "text-primary-light": "#333333",
                        "text-primary-dark": "#E5E7EB",
                        "text-secondary-light": "#8E8E93",
                        "text-secondary-dark": "#92adc9",
                        "destructive": "#FF3B30",
                    },
                    fontFamily: {
                        "display": ["Lexend", "sans-serif"]
                    },
                    borderRadius: {
                        "DEFAULT": "0.25rem",
                        "lg": "0.5rem",
                        "xl": "0.75rem",
                        "full": "9999px"
                    },
                },
            },
        }
    </script>
    <style>
        :root {
            --loading-dot-size: 8px;
            --loading-dot-gap: 8px;
            --loading-animation-duration: 1000ms;
        }
        
        .material-symbols-outlined {
            font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24;
        }
        
        body {
            min-height: max(884px, 100dvh);
        }
        
        .loading-overlay {
            position: fixed;
            inset: 0;
            z-index: 5;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.6);
            transition: opacity 0.2s ease;
        }
        
        .loading-overlay.is-active {
            display: flex;
        }
        
        .loading-dots {
            display: flex;
            gap: var(--loading-dot-gap);
            color: #8E8E93;
        }
        
        .loading-dots span {
            width: var(--loading-dot-size);
            height: var(--loading-dot-size);
            border-radius: 50%;
            background: currentColor;
            opacity: 0.5;
            animation: dotPulse var(--loading-animation-duration) infinite ease-in-out;
            will-change: transform, opacity;
        }
        
        .loading-dots span:nth-child(2) {
            animation-delay: 150ms;
        }
        
        .loading-dots span:nth-child(3) {
            animation-delay: 300ms;
        }
        
        @keyframes dotPulse {
            0% {
                transform: scale(1);
                opacity: 0.35;
            }
            50% {
                transform: scale(1.25);
                opacity: 1;
            }
            100% {
                transform: scale(1);
                opacity: 0.35;
            }
        }
        
        @media (prefers-color-scheme: dark) {
            .loading-dots {
                color: #92adc9;
            }
            
            .loading-overlay {
                background: rgba(0, 0, 0, 0.6);
            }
        }
        
        .study-card {
            user-select: none;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            will-change: transform;
        }
        
        .study-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }
        
        @media (prefers-color-scheme: dark) {
            .study-card:hover {
                box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            }
        }
    </style>
</head>

<body class="bg-background-light dark:bg-background-dark font-display">
    <div class="relative flex min-h-screen w-full flex-col">
        <!-- Main container -->
        <div class="flex-1 pb-24">
            <!-- Top App Bar -->
            <header class="sticky top-0 z-10 bg-background-light/80 dark:bg-background-dark/80 backdrop-blur-sm border-b border-slate-200 dark:border-slate-800">
                <div class="mx-auto max-w-4xl px-3 py-2 flex items-center border-b border-slate-200/70">
                    <button id="backBtn" class="flex h-8 w-8 items-center justify-center rounded-full text-text-primary-light dark:text-text-primary-dark"><span class="material-symbols-outlined text-xl">arrow_back</span></button>
                    <h1 id="deckTitle" class="flex-1 h-8 flex items-center justify-center text-base font-bold tracking-tight text-text-primary-light dark:text-text-primary-dark truncate">Deck</h1>
                    <button id="homeBtn" class="flex h-8 w-8 items-center justify-center rounded-full text-text-primary-light dark:text-text-primary-dark" aria-label="Home">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="h-5 w-5">
                        <path d="M3 10.5L12 3l9 7.5" />
                        <path d="M5 10v9h14v-9" />
                        <path d="M9 19v-6h6v6" />
                    </svg>
                </button>
                </div>
            </header>
            <div id="globalLoader" class="loading-overlay" aria-hidden="true">
                <div class="loading-dots"><span></span><span></span><span></span></div>
            </div>
            <!-- Flashcard List -->
            <main id="listMain" class="mx-auto max-w-4xl p-4">
                <div id="cardGrid" class="w-full"></div>
            </main>
            <section id="studySection" class="mx-auto max-w-4xl p-4 hidden">
                <div class="flex flex-col items-center">
                    <div id="studyCard" class="study-card w-full max-w-md rounded-xl bg-card-light dark:bg-card-dark p-10 text-center text-2xl font-bold text-text-primary-light dark:text-text-primary-dark"></div>
                    <div class="mt-6 flex gap-4">
                        <button id="studyWrong" class="h-11 rounded-full bg-destructive px-6 text-white">Wrong</button>
                        <button id="studyRight" class="h-11 rounded-full bg-primary px-6 text-white">Right</button>
                        <button id="studySpeak" class="h-11 rounded-full bg-yellow-500 px-6 text-white">Speak</button>
                    </div>
                </div>
            </section>
        </div>


        <!-- Confirmation Dialog (hidden by default, example) -->
        <!-- 
        <div class="fixed inset-0 z-40 flex items-center justify-center bg-black/40 p-4">
            <div class="w-full max-w-sm rounded-xl bg-background-light dark:bg-card-dark p-6 text-center shadow-xl">
                <h3 class="text-lg font-bold text-text-primary-light dark:text-text-primary-dark">Delete Card?</h3>
                <p class="mt-2 text-sm text-text-secondary-light dark:text-text-secondary-dark">Are you sure you want to delete this card? This action cannot be undone.</p>
                <div class="mt-6 grid grid-cols-2 gap-3">
                    <button class="h-11 rounded-lg bg-slate-200 font-semibold text-text-primary-light dark:bg-slate-700 dark:text-text-primary-dark">Cancel</button>
                    <button class="h-11 rounded-lg bg-destructive font-semibold text-white">Delete</button>
                </div>
            </div>
        </div>
        -->
    </div>
    <script>
        const backBtn = document.getElementById('backBtn');
        const deckTitle = document.getElementById('deckTitle');
        const homeBtn = document.getElementById('homeBtn');
        const listMain = document.getElementById('listMain');
        const cardGrid = document.getElementById('cardGrid');
        const studySection = document.getElementById('studySection');
        const studyCard = document.getElementById('studyCard');
        const studyWrong = document.getElementById('studyWrong');
        const studyRight = document.getElementById('studyRight');
        const studySpeak = document.getElementById('studySpeak');
        const globalLoader = document.getElementById('globalLoader');
        const appHeader = document.querySelector('header');

        function showLoader() {
            if (globalLoader) globalLoader.classList.add('is-active');
            if (appHeader) appHeader.classList.remove('backdrop-blur-sm');
        }

        function hideLoader() {
            if (globalLoader) globalLoader.classList.remove('is-active');
            if (appHeader) appHeader.classList.add('backdrop-blur-sm');
        }
        const params = new URLSearchParams(location.search);
        const deck = params.get('deck') || '';
        const from = params.get('from') || '';
        if (deck) deckTitle.textContent = deck;
        let cards = [];
        let queue = [];
        let current = null;
        let showingFront = true;
        const frontLang = 'de';
        const backLang = 'en';
        const audioPlayer = new Audio();
        const audioCache = new Map();
        const MAX_CACHE_SIZE = 50;
        
        function cleanupAudioCache() {
            if (audioCache.size > MAX_CACHE_SIZE) {
                const entries = Array.from(audioCache.entries());
                const toRemove = entries.slice(0, entries.length - MAX_CACHE_SIZE);
                toRemove.forEach(([key, url]) => {
                    if (url.startsWith('blob:')) {
                        URL.revokeObjectURL(url);
                    }
                    audioCache.delete(key);
                });
            }
        }
        const eventListeners = [];
        
        function addEventListenerWithCleanup(element, event, handler) {
            element.addEventListener(event, handler);
            eventListeners.push({ element, event, handler });
        }
        
        function cleanupEventListeners() {
            eventListeners.forEach(({ element, event, handler }) => {
                element.removeEventListener(event, handler);
            });
            eventListeners.length = 0;
        }
        
        addEventListenerWithCleanup(backBtn, 'click', () => {
            if (from) location.href = `/folder?name=${encodeURIComponent(from)}`;
            else location.href = '/';
        });
        
        addEventListenerWithCleanup(homeBtn, 'click', () => {
            location.href = '/';
        });
        async function loadDeck() {
            showLoader();
            
            if (!deck) {
                cardGrid.innerHTML = '<div class="col-span-1 sm:col-span-2 lg:col-span-3 mt-10 text-center text-text-secondary-light dark:text-text-secondary-dark">No deck selected</div>';
                hideLoader();
                return;
            }
            
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 10000);
            
            try {
                const response = await fetch(`/cards?deck=${encodeURIComponent(deck)}`, {
                    signal: controller.signal,
                    headers: {
                        'Accept': 'application/json',
                        'Cache-Control': 'no-cache'
                    }
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                cards = Array.isArray(data) ? data : [];
                renderGrid();
                
            } catch (error) {
                if (error.name === 'AbortError') {
                    console.warn('Deck loading timed out');
                    cardGrid.innerHTML = '<div class="mt-10 text-center text-text-secondary-light dark:text-text-secondary-dark">Loading timed out. Please try again.</div>';
                } else {
                    console.error('Failed to load deck:', error);
                    cards = [];
                    cardGrid.innerHTML = '<div class="mt-10 text-center text-text-secondary-light dark:text-text-secondary-dark">Failed to load deck</div>';
                }
            } finally {
                hideLoader();
            }
        }

        function renderGrid() {
            if (!cards.length) {
                cardGrid.innerHTML = '<div class="mt-10 text-center text-text-secondary-light dark:text-text-secondary-dark">This deck is empty</div>';
                return;
            }
            
            const table = document.createElement('table');
            table.className = 'w-full table-fixed border-collapse bg-card-light dark:bg-card-dark rounded-xl overflow-hidden shadow-sm';
            const tbody = document.createElement('tbody');
            table.appendChild(tbody);
            
            cardGrid.innerHTML = '';
            cardGrid.appendChild(table);
            
            const batchSize = 50;
            let index = 0;
            
            function appendBatch() {
                const fragment = document.createDocumentFragment();
                const end = Math.min(index + batchSize, cards.length);
                for (; index < end; index++) {
                    const c = cards[index];
                    const tr = document.createElement('tr');
                    tr.className = 'hover:bg-slate-50 dark:hover:bg-slate-800/40 cursor-pointer';
                    tr.dataset.text = c.de || '';
                    
                    const tdDe = document.createElement('td');
                    tdDe.className = 'align-middle px-3 py-2 text-[15px] font-medium text-text-primary-light dark:text-text-primary-dark border-r border-slate-300 dark:border-slate-700 border-b border-slate-300 dark:border-slate-700 break-words';
                    tdDe.textContent = c.de;
                    
                    const tdEn = document.createElement('td');
                    tdEn.className = 'align-middle px-3 py-2 text-[15px] text-text-secondary-light dark:text-text-secondary-dark border-b border-slate-300 dark:border-slate-700 break-words';
                    tdEn.textContent = c.en;
                    
                    tr.appendChild(tdDe);
                    tr.appendChild(tdEn);
                    fragment.appendChild(tr);
                }
                tbody.appendChild(fragment);
                if (index < cards.length) {
                    requestAnimationFrame(appendBatch);
                }
            }
            
            appendBatch();
        }

        function hydrateAudioFromLocalStorage() {
            cards.forEach(c => {
                const key = `audio:de:${c.de}`;
                const val = localStorage.getItem(key);
                if (val) audioCache.set(c.de, val);
            });
        }
        async function preloadDeckAudio() {
            if (!deck) return;
            
            try {
                const resp = await fetch(`/preload_deck_audio?deck=${encodeURIComponent(deck)}`);
                if (!resp.ok) return;
                
                const data = await resp.json();
                if (!data?.audio_urls) return;
                
                const entries = Object.entries(data.audio_urls);
                const tasks = entries.map(([text, url]) => fetchAudioAndCache(text, url));
                
                await Promise.allSettled(tasks);
            } catch (error) {
                console.warn('Audio preloading failed:', error);
            }
        }
        
        async function fetchAudioAndCache(text, url) {
            const cacheKey = `audio:de:${text}`;
            if (audioCache.has(text) || localStorage.getItem(cacheKey)) return;
            try {
                const response = await fetch(url);
                if (!response.ok) return;
                const blob = await response.blob();
                const objUrl = URL.createObjectURL(blob);
                cleanupAudioCache();
                audioCache.set(text, objUrl);
                try {
                    const base64 = await blobToBase64(blob);
                    localStorage.setItem(cacheKey, base64);
                } catch (storageError) {
                    // Keep in-memory cache even if persistent storage fails
                    console.warn('Storage quota exceeded for audio cache');
                }
            } catch (error) {
                console.warn(`Failed to cache audio for "${text}":`, error);
            }
        }
        
        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }

        function startStudy() {
            if (!cards.length) return;
            queue = cards.slice();
            showingFront = true;
            nextCard();
            listMain.classList.add('hidden');
            studySection.classList.remove('hidden');
        }

        function nextCard() {
            if (!queue.length) {
                studyCard.textContent = 'All done';
                return;
            }
            current = queue.shift();
            showingFront = true;
            studyCard.textContent = current[frontLang];
            autoPlay();
        }

        function flip() {
            if (!current) return;
            studyCard.textContent = showingFront ? current[backLang] : current[frontLang];
            showingFront = !showingFront;
        }
        async function speak(text) {
            if (!text) return;
            
            try {
                audioPlayer.pause();
                audioPlayer.currentTime = 0;
                
                const cacheKey = `audio:de:${text}`;
                const stored = localStorage.getItem(cacheKey);
                if (stored && !audioCache.has(text)) {
                    audioCache.set(text, stored);
                }
                
                if (audioCache.has(text)) {
                    audioPlayer.src = audioCache.get(text);
                    await audioPlayer.play();
                    return;
                }
                
                const resp = await fetch(`/tts?text=${encodeURIComponent(text)}&lang=de`);
                if (resp.ok) {
                    const blob = await resp.blob();
                const url = URL.createObjectURL(blob);
                
                cleanupAudioCache();
                audioCache.set(text, url);
                audioPlayer.src = url;
                await audioPlayer.play();
                }
            } catch (error) {
                console.warn('Audio playback failed:', error);
            }
        }

        function autoPlay() {
            if (frontLang === 'de' && current && current.de) setTimeout(() => speak(current.de), 120);
        }
        addEventListenerWithCleanup(studyCard, 'click', flip);
        addEventListenerWithCleanup(cardGrid, 'click', (e) => {
            const tr = e.target.closest('tr');
            const text = tr ? tr.dataset.text : undefined;
            if (text) speak(text);
        });
        addEventListenerWithCleanup(studyWrong, 'click', () => {
            if (current) queue.push(current);
            nextCard();
        });
        addEventListenerWithCleanup(studyRight, 'click', () => {
            nextCard();
        });
        addEventListenerWithCleanup(studySpeak, 'click', () => {
            if (current && current.de) speak(current.de);
        });
        
        window.addEventListener('beforeunload', cleanupEventListeners);

        async function initializeApp() {
            try {
                hydrateAudioFromLocalStorage();
                await loadDeck();
                if ('requestIdleCallback' in window) {
                    requestIdleCallback(() => preloadDeckAudio());
                } else {
                    setTimeout(preloadDeckAudio, 500);
                }
            } catch (error) {
                console.error('App initialization failed:', error);
            }
        }
        
        initializeApp();
    </script>
</body>

</html>
