<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta name="color-scheme" content="light" />
    <title>Line Generator</title>
    <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
    <link href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;500;600;700&display=swap" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet" />
    <script id="tailwind-config">
        tailwind.config = {
            darkMode: "class",
            theme: {
                extend: {
                    colors: {
                        primary: "#007AFF",
                        "background-light": "#F9F9F9",
                        "background-dark": "#101922",
                        "card-light": "#FFFFFF",
                        "card-dark": "#19242E",
                        "text-primary-light": "#333333",
                        "text-primary-dark": "#E5E7EB",
                        "text-secondary-light": "#8E8E93",
                        "text-secondary-dark": "#92adc9"
                    },
                    fontFamily: {
                        display: [
                            ["Lexend", "sans-serif"]
                        ]
                    },
                    borderRadius: {
                        DEFAULT: "0.25rem",
                        lg: "0.5rem",
                        xl: "0.75rem",
                        full: "9999px"
                    }
                }
            }
        }
    </script>
    <style>
        .material-symbols-outlined {
            font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24;
        }

        .card {
            background: var(--tw-bg-opacity, 1);
        }

        .loading-overlay {
            position: fixed;
            inset: 0;
            z-index: 5;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, .6);
            transition: opacity .2s ease
        }

        .loading-overlay.is-active {
            display: flex;
        }

        .loading-dots {
            display: flex;
            gap: 8px;
            color: #8E8E93
        }

        .loading-dots span {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            opacity: 0.5;
            animation: dotPulse 1000ms infinite ease-in-out;
        }

        .loading-dots span:nth-child(2) {
            animation-delay: 150ms;
        }

        .loading-dots span:nth-child(3) {
            animation-delay: 300ms;
        }

        @keyframes dotPulse {
            0% {
                transform: scale(1);
                opacity: .35
            }

            50% {
                transform: scale(1.25);
                opacity: 1
            }

            100% {
                transform: scale(1);
                opacity: .35
            }
        }

        @media (prefers-color-scheme: dark) {
            .loading-dots {
                color: #92adc9
            }

            .loading-overlay {
                background: rgba(0, 0, 0, .6)
            }
        }

        .tile-enter {
            animation: slideDown 380ms ease-out both;
            will-change: transform, opacity
        }

        @keyframes slideDown {
            0% {
                transform: translateY(-6px);
                opacity: 0
            }

            100% {
                transform: translateY(0);
                opacity: 1
            }
        }

        html {
            color-scheme: light;
        }

        @media (prefers-color-scheme: dark) {
            .loading-overlay {
                background: rgba(255, 255, 255, .6) !important;
            }

            .loading-dots {
                color: #8E8E93 !important;
            }
        }
    </style>
</head>

<body class="bg-background-light dark:bg-background-dark font-display">
    <div class="relative flex min-h-screen w-full flex-col">
        <header
            class="sticky top-0 z-10 bg-background-light/80 dark:bg-background-dark/80 backdrop-blur-sm border-b border-slate-200 dark:border-slate-800">
            <div class="mx-auto max-w-md px-3 py-2 flex items-center gap-2">
                <button id="backBtn"
                    class="flex h-8 w-8 items-center justify-center rounded-full text-text-primary-light dark:text-text-primary-dark"
                    aria-label="Back"><span class="material-symbols-outlined text-xl">arrow_back</span></button>
                <div class="w-8 h-8 shrink-0"></div>
                <div class="flex-1 text-center text-sm font-semibold text-text-secondary-light dark:text-text-secondary-dark"
                    id="progressText"></div>
                <button id="refreshBtn"
                    class="flex h-8 w-8 items-center justify-center rounded-full text-text-primary-light dark:text-text-primary-dark"
                    aria-label="Refresh lines">
                    <span class="material-symbols-outlined text-xl">refresh</span>
                </button>
                <button id="homeBtn"
                    class="flex h-8 w-8 items-center justify-center rounded-full text-text-primary-light dark:text-text-primary-dark"
                    aria-label="Home"><span class="material-symbols-outlined text-xl">home</span></button>
            </div>
        </header>
        <div id="globalLoader" class="loading-overlay" aria-hidden="true">
            <div class="loading-dots"><span></span><span></span><span></span></div>
        </div>

        <main class="mx-auto max-w-md p-4 w-full">
            <div id="lineList" class="space-y-3"></div>
        </main>
    </div>

    <script>
        const params = new URLSearchParams(location.search);
        const deck = params.get('deck') || '';
        const lineList = document.getElementById('lineList');
        const globalLoader = document.getElementById('globalLoader');
        const backBtn = document.getElementById('backBtn');
        const homeBtn = document.getElementById('homeBtn');
        const refreshBtn = document.getElementById('refreshBtn');
        const progressText = document.getElementById('progressText');

        function showLoader() {
            globalLoader.classList.add('is-active');
        }

        function hideLoader() {
            globalLoader.classList.remove('is-active');
        }

        function setStatus(t) {
            progressText.textContent = t || '';
        }

        function init() {
            if (!deck) {
                setStatus('Open Line from a deck');
                return;
            }
            generate();
        }

        let lastItems = [];

        function renderRows(items) {
            lineList.innerHTML = '';
            lastItems = [];
            const shown = [];
            items.forEach((it, i) => {
                const hasContent = ((it.de || '').trim().length +
                    (it.en || '').trim().length +
                    (it.line_en || '').trim().length +
                    (it.line_de || '').trim().length) > 0;
                if (!hasContent) return;
                const card = document.createElement('div');
                card.className = 'rounded-xl bg-card-light dark:bg-card-dark p-4 shadow-sm';
                card.classList.add('tile-enter');
                card.style.animationDelay = `${i * 40}ms`;
                card.innerHTML = `
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <div class="text-xs font-semibold text-text-secondary-light dark:text-text-secondary-dark">German</div>
                            <div class="text-base font-semibold text-text-primary-light dark:text-text-primary-dark word-de" style="cursor:pointer;" data-word="${(it.de || '').replace(/"/g, '&quot;')}">${it.de || ''}</div>
                        </div>
                        <div>
                            <div class="text-xs font-semibold text-text-secondary-light dark:text-text-secondary-dark">English</div>
                            <div class="text-base font-semibold text-text-primary-light dark:text-text-primary-dark">${it.en || ''}</div>
                        </div>
                    </div>
                    <div class="mt-3">
                        <div class="text-xs font-semibold text-text-secondary-light dark:text-text-secondary-dark">German Line</div>
                        <div class="text-sm text-text-primary-light dark:text-text-primary-dark line-de">${it.line_de || ''}</div>
                    </div>
                    <div class="mt-3">
                        <div class="text-xs font-semibold text-text-secondary-light dark:text-text-secondary-dark">English Line</div>
                        <div class="text-sm text-text-primary-light dark:text-text-primary-dark">${it.line_en || ''}</div>
                    </div>
                `;
                lineList.appendChild(card);
                shown.push(it);
                lastItems.push(it);
                // attach word audio click
                const wordEl = card.querySelector('.word-de');
                if (wordEl && (it.de || '').trim()) {
                    wordEl.addEventListener('click', () => {
                        playWord((it.de || '').trim());
                    });
                }
                const btn = card.querySelector('.line-de');
                if (btn && (it.line_de || '').trim()) {
                    btn.style.cursor = 'pointer';
                    btn.addEventListener('click', () => {
                        playLine((it.line_de || '').trim());
                    });
                }
            });
            const total = items.length;
            setStatus(`Generated ${shown.length}${total ? ` of ${total}` : ''} lines`);
        }

        async function generate(refresh = false) {
            if (!deck) {
                setStatus('Select a deck');
                return;
            }
            showLoader();
            try {
                setStatus(refresh ? 'Refreshing...' : 'Generating...');
                const url = `/lines/generate?deck=${encodeURIComponent(deck)}${refresh ? '&refresh=1' : ''}`;
                const resp = await fetch(url);
                const out = await resp.json();
                if (!resp.ok) throw new Error(out.detail || 'Failed');
                renderRows(out.items || []);
                setStatus(`Generated ${out.count} lines`);
                hideLoader();
                const prefetch = fetch(`/preload_lines_audio?deck=${encodeURIComponent(deck)}`)
                    .then(r => r.json())
                    .then(j => {
                        const map = j && j.audio_urls ? j.audio_urls : {};
                        Object.entries(map).forEach(([t, u]) => lineAudioURLs.set(t, u));
                        if ('requestIdleCallback' in window) {
                            requestIdleCallback(() => preloadLineAudio(map));
                        } else {
                            setTimeout(() => preloadLineAudio(map), 300);
                        }
                    })
                    .catch(() => { });
                // Also preload word audio in background
                fetch(`/preload_deck_audio?deck=${encodeURIComponent(deck)}`)
                    .then(r => r.json())
                    .then(j => {
                        const map = j && j.audio_urls ? j.audio_urls : {};
                        Object.entries(map).forEach(([t, u]) => wordAudioURLs.set(t, u));
                        if ('requestIdleCallback' in window) {
                            requestIdleCallback(() => preloadWordAudio(map));
                        } else {
                            setTimeout(() => preloadWordAudio(map), 500);
                        }
                    })
                    .catch(() => { });
            } catch (e) {
                setStatus(String(e.message || e));
                hideLoader();
            }
        }

        const audio = new Audio();
        audio.preload = 'auto';
        const lineAudioURLs = new Map();
        const lineAudioCache = new Map();
        const wordAudioURLs = new Map();
        const wordAudioCache = new Map();

        function playLine(text) {
            const key = `audio:de:${text}`;
            const ls = localStorage.getItem(key);
            if (ls) {
                audio.src = ls;
            } else {
                const cached = lineAudioCache.get(text) || lineAudioURLs.get(text);
                audio.src = cached || `/tts?text=${encodeURIComponent(text)}&lang=de`;
            }
            audio.play().catch(() => { });
        }

        function playWord(text) {
            const cached = wordAudioCache.get(text) || wordAudioURLs.get(text);
            audio.src = cached || `/tts?text=${encodeURIComponent(text)}&lang=de`;
            audio.play().catch(() => { });
        }

        async function preloadLineAudio(map) {
            try {
                const entries = Object.entries(map);
                const tasks = entries.map(([text, url]) => (async () => {
                    try {
                        const r = await fetch(url);
                        if (!r.ok) return;
                        const b = await r.blob();
                        const objUrl = URL.createObjectURL(b);
                        lineAudioCache.set(text, objUrl);
                        const base64 = await new Promise((resolve, reject) => {
                            const fr = new FileReader();
                            fr.onloadend = () => resolve(fr.result);
                            fr.onerror = reject;
                            fr.readAsDataURL(b);
                        });
                        try {
                            localStorage.setItem(`audio:de:${text}`, base64);
                        } catch { }
                    } catch { }
                })());
                await Promise.allSettled(tasks);
            } catch { }
        }

        async function preloadWordAudio(map) {
            try {
                const entries = Object.entries(map);
                const tasks = entries.map(([text, url]) => (async () => {
                    try {
                        if (wordAudioCache.has(text)) return;
                        const r = await fetch(url);
                        if (!r.ok) return;
                        const b = await r.blob();
                        wordAudioCache.set(text, URL.createObjectURL(b));
                    } catch { }
                })());
                await Promise.allSettled(tasks);
            } catch { }
        }

        function exportCSV() {
            const rows = (lastItems || []).map(it => [it.de || '', it.en || '', it.line_en || '', it.line_de || ''].map(x => String(x).replace(/"/g, '""')));
            const header = ['German', 'English', 'English Line', 'German Line'];
            const csv = [header].concat(rows).map(r => r.map(x => `"${x}"`).join(',')).join('\n');
            const blob = new Blob([csv], {
                type: 'text/csv'
            });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = (deck || 'lines') + '.csv';
            document.body.appendChild(a);
            a.click();
            URL.revokeObjectURL(url);
            a.remove();
        }

        backBtn.addEventListener('click', () => { history.length > 1 ? history.back() : location.href = '/' });
        homeBtn.addEventListener('click', () => { location.href = '/' });
        if (refreshBtn) {
            refreshBtn.addEventListener('click', () => {
                // Clear current list and request fresh data from the server
                lineList.innerHTML = '';
                lastItems = [];
                generate(true);
            });
        }
        init();
    </script>
</body>

</html>