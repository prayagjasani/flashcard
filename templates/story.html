<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta content="width=device-width, initial-scale=1.0, viewport-fit=cover" name="viewport" />
    <meta name="color-scheme" content="light" />
    <meta name="theme-color" content="#ffffff" />
    <title>Story Mode</title>
    <link rel="icon" type="image/png" href="/static/favicon.png">
    <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;500;600;700&display=swap" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet" />
    <style>
        :root {
            --bg: #f6f7fb;
            --text: #0f172a;
            --card-bg: #ffffff;
            --card-border: #e5e7eb;
            --shadow: 0 8px 20px rgba(2, 8, 23, 0.06);
            --accent: #3b82f6;
            --success: #10b981;
            --danger: #ef4444;
            --muted: #64748b;
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        html {
            color-scheme: light;
        }

        body {
            margin: 0;
            min-height: 100vh;
            background: radial-gradient(1200px 600px at 50% -200px, #eef2ff 0%, var(--bg) 60%);
            color: var(--text);
            font-family: 'Lexend', ui-sans-serif, system-ui, sans-serif;
        }

        .material-symbols-outlined {
            font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 20;
            font-size: 20px;
        }

        /* Header */

        .site-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 50;
            backdrop-filter: saturate(180%) blur(8px);
            background: rgba(255, 255, 255, 0.85);
            border-bottom: 1px solid rgba(226, 232, 240, 0.7);
        }

        .header__inner {
            max-width: 600px;
            margin: 0 auto;
            padding: 12px 20px;
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .back-btn {
            width: 28px;
            height: 28px;
            border: none;
            background: transparent;
            color: var(--text);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .back-btn:hover {
            background: rgba(0, 0, 0, 0.05);
        }

        .header-title {
            flex: 1;
            font-size: 1rem;
            font-weight: 600;
            text-align: center;
        }

        .header-spacer {
            width: 36px;
        }

        .progress-container {
            flex: 1;
            height: 12px;
            background: var(--card-border);
            border-radius: 6px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: var(--success);
            border-radius: 6px;
            transition: width 0.4s ease;
            width: 0%;
        }

        .progress-text {
            font-size: 14px;
            font-weight: 600;
            color: var(--muted);
            min-width: 50px;
            text-align: right;
        }

        /* Main */

        .main-content {
            padding: 80px 20px 40px;
            max-width: 600px;
            margin: 0 auto;
        }

        .main-content.with-continue {
            padding-bottom: 140px;
        }

        /* Animation */

        .tile-enter {
            animation: slideDown 380ms ease-out both;
            will-change: transform, opacity;
        }

        @keyframes slideDown {
            0% {
                transform: translateY(-6px);
                opacity: 0;
            }

            100% {
                transform: translateY(0);
                opacity: 1;
            }
        }

        /* Loading */

        .loading-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 60vh;
            gap: 16px;
        }

        .loading-dots {
            display: flex;
            gap: 8px;
        }

        .loading-dots span {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--accent);
            animation: dotPulse 1s infinite ease-in-out;
        }

        .loading-dots span:nth-child(2) {
            animation-delay: 150ms;
        }

        .loading-dots span:nth-child(3) {
            animation-delay: 300ms;
        }

        @keyframes dotPulse {

            0%,
            100% {
                transform: scale(1);
                opacity: 0.4;
            }

            50% {
                transform: scale(1.2);
                opacity: 1;
            }
        }

        /* Story list */

        .story-list-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .story-list-header h2 {
            font-size: 1.25rem;
            font-weight: 600;
            margin: 0;
        }

        .create-story-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 0;
            border: none;
            outline: none;
            background: transparent;
            font-size: 1.5rem;
            cursor: pointer;
            font-family: inherit;
            color: var(--text);
        }

        .srt-upload-btn {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            border-radius: 999px;
            border: 1px solid var(--card-border);
            background: var(--card-bg);
            font-size: 0.8rem;
            cursor: pointer;
            font-family: inherit;
            color: var(--muted);
        }

        .srt-upload-btn input[type="file"] {
            display: none;
        }

        .story-item {
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 16px;
            padding: 20px;
            cursor: pointer;
            margin-bottom: 12px;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            user-select: none;
            position: relative;
        }

        .story-item:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow);
        }

        .story-item.holding {
            transform: scale(0.98);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        /* .story-item__title {
            font-weight: 600;
            font-size: 10rem;
            margin: 0 0 4px 0;
            color: var(--text);
        } */

        .story-item__subtitle {
            font-size: 0.9rem;
            color: var(--muted);
            margin: 0 0 0px 0;
        }

        .story-item__meta {
            font-size: 0.75rem;
            color: var(--muted);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .story-item__deck {
            background: #f1f5f9;
            padding: 2px 8px;
            border-radius: 8px;
            font-size: 0.7rem;
        }

        .story-item__level {
            position: absolute;
            top: 4px;
            right: 4px;
            color: #acacac;
            border-radius: 6px;
            padding: 2px 3px;
            font-size: 0.6rem;
            font-weight: 600;
            letter-spacing: 0.02em;
            white-space: nowrap;
        }

        /* Delete popup */

        .action-popup {
            position: fixed;
            inset: 0;
            z-index: 100;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .action-popup.visible {
            display: flex;
        }

        .action-popup__backdrop {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.4);
        }

        .action-popup__content {
            position: relative;
            background: var(--card-bg);
            border-radius: 16px;
            width: 90%;
            max-width: 320px;
            overflow: hidden;
            animation: popupScale 0.2s ease;
        }

        @keyframes popupScale {
            from {
                transform: scale(0.9);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .action-popup__header {
            padding: 20px;
            text-align: center;
            border-bottom: 1px solid var(--card-border);
        }

        .action-popup__title {
            font-size: 1rem;
            font-weight: 600;
            margin: 0 0 4px 0;
        }

        .action-popup__subtitle {
            font-size: 0.85rem;
            color: var(--muted);
            margin: 0;
        }

        .action-popup__actions {
            display: flex;
            flex-direction: column;
        }

        .action-popup__btn {
            padding: 16px;
            border: none;
            background: transparent;
            font-size: 1rem;
            font-family: inherit;
            cursor: pointer;
            border-bottom: 1px solid var(--card-border);
            transition: background 0.15s ease;
        }

        .action-popup__btn:last-child {
            border-bottom: none;
        }

        .action-popup__btn:hover {
            background: #f8fafc;
        }

        .action-popup__btn--danger {
            color: var(--danger);
        }

        .action-popup__btn--cancel {
            color: var(--muted);
        }

        /* Deck selector modal */

        .deck-modal {
            position: fixed;
            inset: 0;
            z-index: 100;
            display: none;
            align-items: flex-end;
            justify-content: center;
        }

        .deck-modal.visible {
            display: flex;
        }

        .deck-modal__backdrop {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.4);
        }

        .deck-modal__content {
            position: relative;
            background: var(--card-bg);
            border-radius: 20px 20px 0 0;
            width: 100%;
            max-width: 600px;
            max-height: 70vh;
            overflow: hidden;
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from {
                transform: translateY(100%);
            }

            to {
                transform: translateY(0);
            }
        }

        .deck-modal__header {
            padding: 20px;
            border-bottom: 1px solid var(--card-border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .deck-modal__header h3 {
            margin: 0;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .deck-modal__close {
            width: 32px;
            height: 32px;
            border: none;
            background: transparent;
            color: var(--muted);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }

        .deck-modal__list {
            padding: 12px;
            overflow-y: auto;
            max-height: calc(70vh - 70px);
        }

        .deck-modal__item {
            padding: 14px 16px;
            border-radius: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: background 0.15s ease;
        }

        .deck-modal__item:hover {
            background: #f1f5f9;
        }

        .deck-modal__item-name {
            font-weight: 500;
        }

        .deck-modal__item-icon {
            color: var(--accent);
        }

        /* Empty state */

        .empty-state {
            text-align: center;
            padding: 60px 20px;
        }

        .empty-state__emoji {
            font-size: 64px;
            margin-bottom: 16px;
        }

        .empty-state__title {
            font-size: 1.25rem;
            font-weight: 600;
            margin: 0 0 8px 0;
        }

        .empty-state__text {
            color: var(--muted);
            margin: 0 0 24px 0;
        }

        /* Story card */

        .story-card {
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 20px;
            overflow: hidden;
            box-shadow: var(--shadow);
            animation: cardSlideUp 0.4s ease forwards;
        }

        @keyframes cardSlideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .story-header {
            background: linear-gradient(145deg, #60a5fa 0%, #3b82f6 100%);
            padding: 24px;
            color: white;
        }

        .story-header-top {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 4px;
        }

        .story-title {
            font-size: 1.5rem;
            font-weight: 700;
            margin: 0;
        }

        .story-header-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .story-subtitle {
            font-size: 0.9rem;
            opacity: 0.9;
            margin: 0;
        }

        .story-level-badge {
            background: rgba(15, 23, 42, 0.22);
            border-radius: 999px;
            padding: 4px 12px;
            font-size: 0.75rem;
            font-weight: 600;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            white-space: nowrap;
        }

        .audio-toggle-btn {
            width: 32px;
            height: 32px;
            border-radius: 999px;
            border: none;
            background: rgba(15, 23, 42, 0.06);
            color: var(--text);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .audio-toggle-btn-icon {
            font-size: 20px;
        }

        .audio-toggle-btn.audio-off {
            background: rgba(148, 163, 184, 0.25);
            color: #6b7280;
        }

        /* Story segment */

        .story-segment {
            padding: 24px;
            border-bottom: 1px solid var(--card-border);
            will-change: opacity, transform;
            transform-origin: center bottom;
            backface-visibility: hidden;
            opacity: 1;
            transform: translate3d(0, 0, 0);
            transition: opacity 0.3s cubic-bezier(0.16, 1, 0.3, 1), transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
        }

        .story-segment:last-child {
            border-bottom: none;
        }

        .story-segment-enter {
            opacity: 0;
            transform: translate3d(0, 8px, 0);
        }

        .segment-narration {
            background: #f3f3f3;
        }

        .segment-dialogue {
            background: var(--card-bg);
        }

        .segment-speaker {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
            position: relative;
        }

        .segment-speaker .audio-btn {
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
        }

        .speaker-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #f472b6 0%, #ec4899 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            color: white;
            font-size: 1rem;
        }

        .speaker-avatar.avatar-1 {
            background: linear-gradient(145deg, #60a5fa 0%, #3b82f6 100%);
        }

        .speaker-avatar.avatar-2 {
            background: linear-gradient(145deg, #f472b6 0%, #ec4899 100%);
        }

        .speaker-avatar.avatar-3 {
            background: linear-gradient(145deg, #34d399 0%, #10b981 100%);
        }

        .speaker-avatar.avatar-4 {
            background: linear-gradient(145deg, #fbbf24 0%, #f59e0b 100%);
        }

        .speaker-name {
            font-weight: 600;
            color: var(--text);
            flex: 1;
        }

        .segment-content {
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }

        .audio-btn {
            width: 32px;
            height: 32px;
            border: none;
            background: rgba(59, 130, 246, 0.1);
            color: var(--accent);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: background 0.15s ease, transform 0.15s ease;
        }

        .audio-btn:hover {
            background: rgba(59, 130, 246, 0.2);
        }

        .audio-btn:active {
            transform: scale(0.92);
        }

        .segment-text {
            font-size: 1rem;
            line-height: 1.5;
            color: var(--text);
            flex: 1;
            margin: 0;
        }

        .segment-translation {
            margin-top: 4px;
            font-size: 0.9rem;
            line-height: 1.5;
            color: var(--muted);
        }

        .word-highlight {
            padding: 1px 4px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.15s ease;
        }

        /* Colored highlights for vocabulary words */

        .highlight-0 {
            background: rgba(147, 197, 253, 0.5);
        }

        /* Blue */

        .highlight-1 {
            background: rgba(254, 202, 202, 0.5);
        }

        /* Pink/Red */

        .highlight-2 {
            background: rgba(167, 243, 208, 0.5);
        }

        /* Green */

        .highlight-3 {
            background: rgba(253, 230, 138, 0.5);
        }

        /* Yellow */

        .highlight-4 {
            background: rgba(196, 181, 253, 0.5);
        }

        /* Purple */

        .highlight-5 {
            background: rgba(254, 215, 170, 0.5);
        }

        /* Orange */

        .highlight-6 {
            background: rgba(165, 243, 252, 0.5);
        }

        /* Cyan */

        .highlight-7 {
            background: rgba(252, 211, 235, 0.5);
        }

        /* Pink light */

        .highlight-8 {
            background: rgba(134, 239, 172, 0.5);
        }

        /* Lime */

        .highlight-9 {
            background: rgba(249, 168, 212, 0.5);
        }

        /* Rose */

        .highlight-10 {
            background: rgba(147, 51, 234, 0.25);
        }

        /* Violet */

        .highlight-11 {
            background: rgba(251, 191, 36, 0.4);
        }

        /* Amber */

        .highlight-12 {
            background: rgba(56, 189, 248, 0.4);
        }

        /* Sky */

        .highlight-13 {
            background: rgba(248, 113, 113, 0.4);
        }

        /* Red */

        .highlight-14 {
            background: rgba(74, 222, 128, 0.4);
        }

        /* Emerald */

        .highlight-15 {
            background: rgba(232, 121, 249, 0.4);
        }

        /* Fuchsia */

        .word-highlight:hover {
            filter: brightness(0.9);
        }

        .tappable-word {
            cursor: pointer;
            padding: 1px 2px;
            border-radius: 4px;
            transition: background 0.15s ease;
        }

        .tappable-word:hover {
            background: rgba(59, 130, 246, 0.1);
        }

        .tappable-word:active {
            background: rgba(59, 130, 246, 0.2);
        }

        .segment-translation {
            margin-top: 4px;
            padding-top: 4px;
            border-top: 1px dotted var(--card-border);
            font-size: 0.9rem;
            color: var(--muted);
        }

        .tap-hint {
            text-align: center;
            padding: 12px;
            color: var(--muted);
            font-size: 0.875rem;
        }

        /* Continue button */

        .continue-container {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 20px;
            background: linear-gradient(to top, var(--bg) 60%, transparent);
        }

        .continue-btn {
            display: block;
            width: 100%;
            max-width: 560px;
            margin: 0 auto;
            padding: 16px 24px;
            border: none;
            background: var(--success);
            color: white;
            font-size: 1rem;
            font-weight: 700;
            border-radius: 12px;
            cursor: pointer;
            box-shadow: 0 4px 0 #059669;
            transition: transform 0.1s ease, box-shadow 0.1s ease;
            font-family: inherit;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .continue-btn:hover {
            filter: brightness(1.05);
        }

        .continue-btn:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 #059669;
        }

        /* Completed */

        .completed-card {
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 20px;
            padding: 40px 24px;
            box-shadow: var(--shadow);
            text-align: center;
            animation: cardSlideUp 0.4s ease forwards;
        }

        .completed-emoji {
            font-size: 72px;
            margin-bottom: 16px;
        }

        .completed-title {
            font-size: 1.5rem;
            font-weight: 700;
            margin: 0 0 8px 0;
        }

        .completed-subtitle {
            color: var(--muted);
            margin: 0 0 32px 0;
        }

        .btn-secondary {
            display: block;
            width: 100%;
            padding: 14px 24px;
            border: 1px solid var(--card-border);
            background: var(--card-bg);
            color: var(--text);
            font-size: 1rem;
            font-weight: 600;
            border-radius: 12px;
            cursor: pointer;
            font-family: inherit;
            margin-top: 12px;
        }

        .btn-secondary:hover {
            background: #f1f5f9;
        }

        @keyframes spin {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        /* Tooltip */

        .tooltip {
            position: fixed;
            background: var(--text);
            color: white;
            padding: 8px 14px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            opacity: 0;
            transform: translate(-50%, -100%) translateY(-5px);
            transition: opacity 0.2s ease, transform 0.2s ease;
            pointer-events: none;
        }

        .tooltip.visible {
            opacity: 1;
            transform: translate(-50%, -100%) translateY(0);
        }
    </style>
</head>

<body>
    <header class="site-header">
        <div class="header__inner">
            <button class="back-btn" id="backBtn">
                <span class="material-symbols-outlined">arrow_back</span>
            </button>

            <span class="header-title" id="headerTitle">Stories</span>
            <div class="story-list-header">
                <button class="create-story-btn" id="createStoryBtn">+</button>
            </div>

            <div class="progress-container" id="progressContainer" style="display: none;">
                <div class="progress-bar" id="progressBar"></div>
            </div>
            <span class="progress-text" id="progressText" style="display: none;">0/0</span>
            <button class="audio-toggle-btn" id="refreshTranslationsBtn" type="button" style="display:none;"
                title="Refresh translations">
                <span class="material-symbols-outlined audio-toggle-btn-icon">refresh</span>
            </button>
            <button class="audio-toggle-btn" id="audioToggleBtn" type="button" style="display:none;">
                <span class="material-symbols-outlined audio-toggle-btn-icon" id="audioToggleIcon">volume_up</span>
            </button>
        </div>
    </header>

    <main class="main-content" id="mainContent">
        <!-- Loading -->
        <div id="loadingState" class="loading-container">
            <div class="loading-dots">
                <span></span><span></span><span></span>
            </div>
            <p style="color: var(--muted);" id="loadingText">Loading stories...</p>
        </div>

        <!-- Story list -->
        <div id="storyListView" style="display: none;">
            <div
                style="display:flex; justify-content: space-between; align-items: center; margin-bottom: 12px; padding: 0 4px;">
                <span style="font-size:0.9rem; color: var(--muted);">Stories</span>
                <div style="display:flex; gap: 8px;">
                    <button id="youtubeLinkBtn"
                        style="display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px; border:1px solid var(--card-border); background:var(--card-bg); font-size:0.8rem; cursor:pointer; font-family:inherit; color:var(--muted);">
                        <span class="material-symbols-outlined" style="font-size:16px;">play_circle</span>
                        <span style="white-space:nowrap;">YouTube</span>
                    </button>
                    <label class="srt-upload-btn">
                        <span class="material-symbols-outlined" style="font-size:16px;">upload</span>
                        <span style="white-space: nowrap;">Use .srt subtitles</span>
                        <input type="file" id="srtFileInput" accept=".srt">
                    </label>
                </div>
            </div>
            <div id="storyList"></div>
        </div>

        <!-- Story reading view -->
        <div id="storyContent" style="display: none;">
            <div class="story-card" id="storyCard">
                <div class="story-header">
                    <div class="story-header-top">
                        <h1 class="story-title" id="storyTitle"></h1>
                        <div class="story-header-right">
                            <span class="story-level-badge" id="storyLevelBadge" style="display: none;"></span>
                        </div>
                    </div>
                    <p class="story-subtitle" id="storySubtitle"></p>
                </div>
                <div id="segmentsContainer"></div>
                <div class="tap-hint" id="tapHint">
                    <span class="material-symbols-outlined"
                        style="font-size: 16px; vertical-align: middle;">touch_app</span> Tap any word for meaning
                </div>
            </div>
        </div>

        <!-- Completed -->
        <div id="completedState" style="display: none;">
            <div class="completed-card">
                <div class="completed-emoji">ðŸŽ‰</div>
                <h2 class="completed-title">Story Complete!</h2>
                <p class="completed-subtitle">Great job reading the story!</p>
                <button class="continue-btn" id="restartBtn">Read Again</button>
                <button class="btn-secondary" id="backToListBtn">Back to Stories</button>
            </div>
        </div>
    </main>

    <!-- Continue -->
    <div class="continue-container" id="continueContainer" style="display: none;">
        <button class="continue-btn" id="continueBtn">Continue</button>
    </div>

    <!-- Action popup (delete) -->
    <div class="action-popup" id="actionPopup">
        <div class="action-popup__backdrop" id="actionPopupBackdrop"></div>
        <div class="action-popup__content">
            <div class="action-popup__header">
                <h3 class="action-popup__title" id="actionPopupTitle"></h3>
                <p class="action-popup__subtitle" id="actionPopupSubtitle"></p>
            </div>
            <div class="action-popup__actions">
                <button class="action-popup__btn action-popup__btn--danger" id="deleteStoryBtn">
                    <span class="material-symbols-outlined"
                        style="font-size: 18px; vertical-align: middle; margin-right: 8px;">delete</span>
                    Delete Story
                </button>
                <button class="action-popup__btn action-popup__btn--cancel" id="cancelActionBtn">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Create story modal -->
    <div class="deck-modal" id="createModal">
        <div class="deck-modal__backdrop" id="createModalBackdrop"></div>
        <div class="deck-modal__content" style="border-radius: 20px; max-height: none;">
            <div class="deck-modal__header">
                <h3>Create New Story</h3>
                <button class="deck-modal__close" id="createModalClose">
                    <span class="material-symbols-outlined">close</span>
                </button>
            </div>
            <div style="padding: 20px;">
                <!-- Tabs -->
                <div style="display:flex; gap:8px; margin-bottom:16px;">
                    <button id="tabAI" onclick="switchCreateTab('ai')"
                        style="flex:1; padding:8px; border-radius:10px; border:2px solid var(--accent); background:var(--accent); color:#fff; font-family:inherit; font-weight:600; cursor:pointer; font-size:0.85rem;">ðŸ¤–
                        AI Story</button>
                    <button id="tabText" onclick="switchCreateTab('text')"
                        style="flex:1; padding:8px; border-radius:10px; border:2px solid var(--card-border); background:var(--card-bg); color:var(--text); font-family:inherit; font-weight:600; cursor:pointer; font-size:0.85rem;">ðŸ“„
                        Paste Text</button>
                    <button id="tabYT" onclick="switchCreateTab('yt')"
                        style="flex:1; padding:8px; border-radius:10px; border:2px solid var(--card-border); background:var(--card-bg); color:var(--text); font-family:inherit; font-weight:600; cursor:pointer; font-size:0.85rem;">â–¶
                        YouTube</button>
                </div>

                <!-- Tab: AI -->
                <div id="tabContentAI">
                    <p style="color: var(--muted); font-size: 0.9rem; margin: 0 0 16px 0;">What kind of story would you
                        like to read?</p>
                    <input type="text" id="storyTopicInput"
                        placeholder="e.g., a trip to the airport, ordering food at a cafÃ©..."
                        style="width: 100%; padding: 14px 16px; border: 1px solid var(--card-border); border-radius: 12px; font-size: 1rem; font-family: inherit; outline: none; box-sizing: border-box;">
                    <div
                        style="margin-top: 12px; display: flex; gap: 8px; align-items: center; justify-content: space-between; flex-wrap: wrap;">
                        <label for="storyLevelSelect" style="font-size: 0.85rem; color: var(--muted);">German
                            level</label>
                        <select id="storyLevelSelect"
                            style="width: -webkit-fill-available; padding: 8px 12px; border-radius: 999px; border: 1px solid var(--card-border); font-size: 0.85rem; font-family: inherit; background: var(--card-bg);">
                            <option value="A1">A1 â€“ Beginner</option>
                            <option value="A2" selected>A2 â€“ Elementary</option>
                            <option value="B1">B1 â€“ Intermediate</option>
                            <option value="B2">B2 â€“ Upper-Intermediate</option>
                            <option value="C1">C1 â€“ Advanced</option>
                            <option value="C2">C2 â€“ Proficient</option>
                        </select>
                    </div>
                    <div style="margin-top: 16px; display: flex; gap: 12px;">
                        <button class="continue-btn" id="createStorySubmit" style="flex: 1; padding: 14px;">Create
                            Story</button>
                    </div>
                    <button id="randomStoryBtn"
                        style="width: 100%; margin-top: 12px; padding: 14px; border: 1px solid var(--card-border); background: var(--card-bg); color: var(--text); font-size: 1rem; font-weight: 600; border-radius: 12px; cursor: pointer; font-family: inherit; display: flex; align-items: center; justify-content: center; gap: 8px;">
                        <span class="material-symbols-outlined" style="font-size: 20px;">shuffle</span>
                        Surprise Me!
                    </button>
                    <p style="color: var(--muted); font-size: 0.8rem; margin: 16px 0 0 0; text-align: center;">Stories
                        are generated using AI with German vocabulary</p>
                </div>

                <!-- Tab: Paste Text -->
                <div id="tabContentText" style="display:none;">
                    <p style="color: var(--muted); font-size: 0.9rem; margin: 0 0 12px 0;">Paste your German text below
                        â€” each line becomes a segment.</p>
                    <textarea id="storyTextInput" placeholder="Paste your German story or subtitle text here..."
                        style="width: 100%; min-height: 120px; padding: 12px 14px; border: 1px solid var(--card-border); border-radius: 12px; font-size: 0.95rem; font-family: inherit; outline: none; resize: vertical; box-sizing: border-box;"></textarea>
                    <div
                        style="margin-top: 12px; display: flex; gap: 8px; align-items: center; justify-content: space-between; flex-wrap: wrap;">
                        <label style="font-size: 0.85rem; color: var(--muted);">German level</label>
                        <select id="textLevelSelect"
                            style="width: -webkit-fill-available; padding: 8px 12px; border-radius: 999px; border: 1px solid var(--card-border); font-size: 0.85rem; font-family: inherit; background: var(--card-bg);">
                            <option value="A1">A1 â€“ Beginner</option>
                            <option value="A2" selected>A2 â€“ Elementary</option>
                            <option value="B1">B1 â€“ Intermediate</option>
                            <option value="B2">B2 â€“ Upper-Intermediate</option>
                            <option value="C1">C1 â€“ Advanced</option>
                            <option value="C2">C2 â€“ Proficient</option>
                        </select>
                    </div>
                    <button class="continue-btn" id="submitTextStoryBtn"
                        style="width:100%; margin-top:16px; padding:14px;">Process Text</button>
                </div>

                <!-- Tab: YouTube -->
                <div id="tabContentYT" style="display:none;">
                    <p style="color: var(--muted); font-size: 0.9rem; margin: 0 0 12px 0;">
                        Paste a YouTube link to a German video. We'll extract the subtitles and translate them line by
                        line.
                    </p>
                    <input type="url" id="ytUrlInput" placeholder="https://www.youtube.com/watch?v=..."
                        style="width:100%; padding:14px 16px; border:1px solid var(--card-border); border-radius:12px; font-size:1rem; font-family:inherit; outline:none; box-sizing:border-box;">
                    <div
                        style="margin-top: 12px; display: flex; gap: 8px; align-items: center; justify-content: space-between; flex-wrap: wrap;">
                        <label style="font-size: 0.85rem; color: var(--muted);">German level</label>
                        <select id="ytLevelSelect"
                            style="width: -webkit-fill-available; padding: 8px 12px; border-radius: 999px; border: 1px solid var(--card-border); font-size: 0.85rem; font-family: inherit; background: var(--card-bg);">
                            <option value="A1">A1 â€“ Beginner</option>
                            <option value="A2" selected>A2 â€“ Elementary</option>
                            <option value="B1">B1 â€“ Intermediate</option>
                            <option value="B2">B2 â€“ Upper-Intermediate</option>
                            <option value="C1">C1 â€“ Advanced</option>
                            <option value="C2">C2 â€“ Proficient</option>
                        </select>
                    </div>
                    <button class="continue-btn" id="submitYTBtn" style="width:100%; margin-top:16px; padding:14px;">
                        <span class="material-symbols-outlined"
                            style="font-size:20px; vertical-align:middle; margin-right:6px;">play_circle</span>
                        Extract &amp; Translate
                    </button>
                    <p id="ytError" style="color:var(--danger); font-size:0.85rem; margin:10px 0 0 0; display:none;">
                    </p>
                    <p style="color: var(--muted); font-size: 0.75rem; margin: 12px 0 0 0; text-align: center;">Requires
                        German subtitles (manual or auto-generated) on the video</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Tooltip -->
    <div class="tooltip" id="tooltip"></div>

    <script>
        // DOM
        const backBtn = document.getElementById('backBtn');
        const headerTitle = document.getElementById('headerTitle');
        const progressContainer = document.getElementById('progressContainer');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const mainContent = document.getElementById('mainContent');
        const loadingState = document.getElementById('loadingState');
        const loadingText = document.getElementById('loadingText');
        const storyListView = document.getElementById('storyListView');
        const storyList = document.getElementById('storyList');
        const createStoryBtn = document.getElementById('createStoryBtn');
        const storyContent = document.getElementById('storyContent');
        const storyCard = document.getElementById('storyCard');
        const storyTitle = document.getElementById('storyTitle');
        const storySubtitle = document.getElementById('storySubtitle');
        const segmentsContainer = document.getElementById('segmentsContainer');
        const completedState = document.getElementById('completedState');
        const continueContainer = document.getElementById('continueContainer');
        const continueBtn = document.getElementById('continueBtn');
        const restartBtn = document.getElementById('restartBtn');
        const backToListBtn = document.getElementById('backToListBtn');
        const actionPopup = document.getElementById('actionPopup');
        const actionPopupBackdrop = document.getElementById('actionPopupBackdrop');
        const actionPopupTitle = document.getElementById('actionPopupTitle');
        const actionPopupSubtitle = document.getElementById('actionPopupSubtitle');
        const deleteStoryBtn = document.getElementById('deleteStoryBtn');
        const cancelActionBtn = document.getElementById('cancelActionBtn');
        const createModal = document.getElementById('createModal');
        const createModalBackdrop = document.getElementById('createModalBackdrop');
        const createModalClose = document.getElementById('createModalClose');
        const storyTopicInput = document.getElementById('storyTopicInput');
        const storyTextInput = document.getElementById('storyTextInput');
        const storyLevelSelect = document.getElementById('storyLevelSelect');
        const createStorySubmit = document.getElementById('createStorySubmit');
        const randomStoryBtn = document.getElementById('randomStoryBtn');
        const tooltip = document.getElementById('tooltip');
        const storyLevelBadge = document.getElementById('storyLevelBadge');
        const srtFileInput = document.getElementById('srtFileInput');
        const audioToggleBtn = document.getElementById('audioToggleBtn');
        const audioToggleIcon = document.getElementById('audioToggleIcon');
        const refreshTranslationsBtn = document.getElementById('refreshTranslationsBtn');

        // State
        const params = new URLSearchParams(location.search);
        let currentDeck = params.get('deck') || '';
        let story = null;
        let vocabulary = {};
        let sentenceUnits = [];

        // Common German words fallback dictionary
        const commonWords = {
            'ich': 'I',
            'du': 'you',
            'er': 'he',
            'sie': 'she/they',
            'es': 'it',
            'wir': 'we',
            'ihr': 'you (pl.)',
            'der': 'the',
            'die': 'the',
            'das': 'the',
            'ein': 'a/an',
            'eine': 'a/an',
            'ist': 'is',
            'bin': 'am',
            'bist': 'are',
            'sind': 'are',
            'war': 'was',
            'waren': 'were',
            'hat': 'has',
            'habe': 'have',
            'haben': 'have',
            'hatte': 'had',
            'hatten': 'had',
            'und': 'and',
            'oder': 'or',
            'aber': 'but',
            'weil': 'because',
            'wenn': 'if/when',
            'nicht': 'not',
            'kein': 'no/none',
            'keine': 'no/none',
            'was': 'what',
            'wer': 'who',
            'wo': 'where',
            'wie': 'how',
            'warum': 'why',
            'wann': 'when',
            'hier': 'here',
            'dort': 'there',
            'da': 'there',
            'jetzt': 'now',
            'dann': 'then',
            'immer': 'always',
            'sehr': 'very',
            'so': 'so',
            'auch': 'also',
            'nur': 'only',
            'noch': 'still/yet',
            'mit': 'with',
            'zu': 'to',
            'in': 'in',
            'an': 'at/on',
            'auf': 'on',
            'fÃ¼r': 'for',
            'von': 'from',
            'mein': 'my',
            'dein': 'your',
            'sein': 'his',
            'ihr': 'her',
            'unser': 'our',
            'ja': 'yes',
            'nein': 'no',
            'gut': 'good',
            'schlecht': 'bad',
            'groÃŸ': 'big',
            'klein': 'small',
            'kann': 'can',
            'muss': 'must',
            'will': 'want',
            'soll': 'should',
            'darf': 'may',
            'gehen': 'go',
            'kommen': 'come',
            'sehen': 'see',
            'machen': 'make/do',
            'sagen': 'say',
            'mehr': 'more',
            'alle': 'all',
            'viel': 'much',
            'wenig': 'little',
            'etwas': 'something',
            'ans': 'to the',
            'ins': 'into the',
            'beim': 'at the',
            'zum': 'to the',
            'vom': 'from the'
        };
        let currentSegmentIndex = 0;
        let renderedSegmentCount = 0;
        let audioPlayer = new Audio();
        let audioCache = new Map();
        const AUDIO_PREFETCH_BATCH = 25;
        let audioPrefetchEnd = 0;
        let characters = [];
        let allDecks = [];
        let allStories = [];
        let isReadingMode = false;
        let selectedStoryForAction = null;
        let longPressTimer = null;
        const LONG_PRESS_DURATION = 500;
        let isAudioEnabled = true;

        const avatarClasses = ['avatar-1', 'avatar-2', 'avatar-3', 'avatar-4'];

        function addToVocabulary(de, en) {
            if (!de || !en) return;
            const lower = de.toLowerCase();
            const cleaned = lower.replace(/[.,!?;:'"â€ž"Â»Â«()]/g, '');
            if (!vocabulary[lower]) vocabulary[lower] = en;
            if (cleaned && !vocabulary[cleaned]) vocabulary[cleaned] = en;
            lower.split(/\s+/).forEach(part => {
                const partClean = part.replace(/[.,!?;:'"â€ž"Â»Â«()]/g, '');
                if (partClean && !vocabulary[partClean]) {
                    vocabulary[partClean] = en;
                }
            });
        }

        function getAvatarClass(name) {
            const idx = characters.indexOf(name);
            return avatarClasses[idx % avatarClasses.length];
        }

        function getInitial(name) {
            return (name || 'N')[0].toUpperCase();
        }

        // Init
        async function init() {
            if (currentDeck) {
                await loadStory(currentDeck);
            } else {
                await loadStoryList();
            }
        }

        async function loadStoryList() {
            // Check cache first for instant rendering
            try {
                const cachedStories = sessionStorage.getItem('cached_stories');
                const cachedDecks = sessionStorage.getItem('cached_decks_for_stories');

                if (cachedStories && cachedDecks) {
                    allStories = JSON.parse(cachedStories);
                    allDecks = JSON.parse(cachedDecks);

                    // Show cached text immediately
                    loadingState.style.display = 'none';
                    storyListView.style.display = 'block';
                    storyContent.style.display = 'none';
                    completedState.style.display = 'none';
                    continueContainer.style.display = 'none';

                    headerTitle.style.display = 'block';
                    createStoryBtn.style.display = 'flex';
                    progressContainer.style.display = 'none';
                    progressText.style.display = 'none';
                    if (audioToggleBtn) audioToggleBtn.style.display = 'none';
                    if (refreshTranslationsBtn) refreshTranslationsBtn.style.display = 'none';
                    mainContent.classList.remove('with-continue');
                    isReadingMode = false;

                    renderStoryList();
                } else {
                    // Only show loader if no cache
                    loadingState.style.display = 'flex';
                    loadingText.textContent = 'Loading stories...';
                    storyListView.style.display = 'none';
                    storyContent.style.display = 'none';
                    completedState.style.display = 'none';
                    continueContainer.style.display = 'none';

                    headerTitle.style.display = 'block';
                    createStoryBtn.style.display = 'flex';
                    progressContainer.style.display = 'none';
                    progressText.style.display = 'none';
                    if (audioToggleBtn) audioToggleBtn.style.display = 'none';
                    if (refreshTranslationsBtn) refreshTranslationsBtn.style.display = 'none';
                    mainContent.classList.remove('with-continue');
                    isReadingMode = false;
                }
            } catch (e) {
                // Ignore cache errors
            }

            try {
                const [storiesResp, decksResp] = await Promise.all([
                    fetch('/stories/list'),
                    fetch('/decks')
                ]);

                const storiesData = await storiesResp.json();
                const decksData = await decksResp.json();

                const newStories = storiesData.stories || [];
                const newDecks = Array.isArray(decksData) ? decksData : [];

                // Compare with current data to avoid re-render (which restarts animation)
                const isStoriesChanged = JSON.stringify(newStories) !== JSON.stringify(allStories);
                const isDecksChanged = JSON.stringify(newDecks) !== JSON.stringify(allDecks);

                if (!isStoriesChanged && !isDecksChanged) {
                    loadingState.style.display = 'none';
                    return; // Data is same, skip re-render
                }

                allStories = newStories;
                allDecks = newDecks;

                // Update cache
                try {
                    sessionStorage.setItem('cached_stories', JSON.stringify(allStories));
                    sessionStorage.setItem('cached_decks_for_stories', JSON.stringify(allDecks));
                } catch (e) { }

                loadingState.style.display = 'none';
                renderStoryList();

            } catch (error) {
                console.error('Failed to load stories:', error);

                // Only show error state if we didn't show cached content
                if (storyListView.style.display === 'none') {
                    loadingState.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state__emoji">ðŸ˜•</div>
                            <h3 class="empty-state__title">Failed to load stories</h3>
                            <button class="continue-btn" onclick="location.href='/'">Go to Home</button>
                        </div>
                    `;
                }
            }
        }

        function renderStoryList() {
            storyListView.style.display = 'block';

            if (allStories.length === 0) {
                storyList.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state__emoji">ðŸ“–</div>
                        <h3 class="empty-state__title">No stories yet</h3>
                        <p class="empty-state__text">Create your first AI-generated story!</p>
                    </div>
                `;
                return;
            }

            // Sort by most recent
            allStories.sort((a, b) => {
                const dateA = a.last_modified ? new Date(a.last_modified) : new Date(0);
                const dateB = b.last_modified ? new Date(b.last_modified) : new Date(0);
                return dateB - dateA;
            });

            storyList.innerHTML = allStories.map((s, i) => {
                const title = s.title_de || s.deck;
                const subtitle = s.title_en || '';
                const level = s.level || '';
                // Stagger animation: 40ms per item
                const delay = i * 40;
                return `
                    <div class="story-item tile-enter" style="animation-delay: ${delay}ms;" data-deck="${s.deck}" data-title="${title}">
                        ${level ? `<span class="story-item__level">${level}</span>` : ''}
                        <!-- <h3 class="story-item__title">${title}</h3> -->
                        ${subtitle ? `<p class="story-item__subtitle">${subtitle}</p>` : ''}
                    </div>
                `;
            }).join('');

            // Add click and long-press handlers
            storyList.querySelectorAll('.story-item').forEach(item => {
                // Click to open
                item.addEventListener('click', (e) => {
                    if (longPressTimer) return; // Ignore if long press was triggered
                    const deck = item.dataset.deck;
                    loadStory(deck);
                });

                // Long press to delete
                item.addEventListener('pointerdown', (e) => {
                    item.classList.add('holding');
                    longPressTimer = setTimeout(() => {
                        item.classList.remove('holding');
                        openActionPopup(item.dataset.deck, item.dataset.title);
                        longPressTimer = null;
                    }, LONG_PRESS_DURATION);
                });

                item.addEventListener('pointerup', () => {
                    item.classList.remove('holding');
                    if (longPressTimer) {
                        clearTimeout(longPressTimer);
                        longPressTimer = null;
                    }
                });

                item.addEventListener('pointerleave', () => {
                    item.classList.remove('holding');
                    if (longPressTimer) {
                        clearTimeout(longPressTimer);
                        longPressTimer = null;
                    }
                });

                item.addEventListener('pointercancel', () => {
                    item.classList.remove('holding');
                    if (longPressTimer) {
                        clearTimeout(longPressTimer);
                        longPressTimer = null;
                    }
                });
            });
        }

        // function getTimeAgo(date) {
        //     const now = new Date();
        //     const diff = now - date;
        //     const minutes = Math.floor(diff / 60000);
        //     const hours = Math.floor(diff / 3600000);
        //     const days = Math.floor(diff / 86400000);

        //     if (minutes < 1) return 'Just now';
        //     if (minutes < 60) return `${minutes}m ago`;
        //     if (hours < 24) return `${hours}h ago`;
        //     if (days < 7) return `${days}d ago`;
        //     return date.toLocaleDateString();
        // }

        // Action popup
        function openActionPopup(deck, title) {
            selectedStoryForAction = deck;
            actionPopupTitle.textContent = title;
            actionPopupSubtitle.textContent = `From deck: ${deck}`;
            actionPopup.classList.add('visible');
        }

        function closeActionPopup() {
            actionPopup.classList.remove('visible');
            selectedStoryForAction = null;
        }

        function deleteSelectedStory() {
            if (!selectedStoryForAction) return;

            const deck = selectedStoryForAction;
            closeActionPopup();

            // Remove from UI immediately
            allStories = allStories.filter(s => s.deck !== deck);
            renderStoryList();

            // Delete in background (fire-and-forget)
            fetch(`/story/delete?deck=${encodeURIComponent(deck)}`, {
                method: 'DELETE'
            }).catch(err => console.warn('Background delete failed:', err));
        }

        function splitTextIntoSentences(text) {
            const result = [];
            if (!text) return result;
            let current = '';
            for (let i = 0; i < text.length; i++) {
                const ch = text[i];
                current += ch;
                if (ch === '.' || ch === '!' || ch === '?') {
                    let j = i + 1;
                    while (j < text.length && /\s/.test(text[j])) {
                        j++;
                    }
                    result.push(current.trim());
                    current = '';
                    i = j - 1;
                }
            }
            if (current.trim()) {
                result.push(current.trim());
            }
            return result;
        }

        function rebuildSentenceUnits() {
            sentenceUnits = [];
            if (!story || !Array.isArray(story.segments)) return;
            for (let segIndex = 0; segIndex < story.segments.length; segIndex++) {
                const seg = story.segments[segIndex] || {};
                const textDe = (seg.text_de || '').trim();
                const textEn = (seg.text_en || '').trim();
                if (!textDe) continue;
                const deParts = splitTextIntoSentences(textDe);
                const enParts = textEn ? splitTextIntoSentences(textEn) : [];
                deParts.forEach((deSentence, idx) => {
                    sentenceUnits.push({
                        segmentIndex: segIndex,
                        sentenceIndex: idx,
                        text_de: deSentence,
                        text_en: enParts[idx] || textEn,
                        type: seg.type || 'narration',
                        speaker: seg.speaker || 'narrator',
                        highlight_pairs: seg.highlight_pairs || [],
                        highlight_words: seg.highlight_words || [],
                        full_vocabulary: seg.full_vocabulary || null
                    });
                });
            }
        }

        async function loadStory(deck, refresh = false) {
            currentDeck = deck;

            // Clear previous caches
            audioCache.forEach(url => {
                if (url.startsWith('blob:')) URL.revokeObjectURL(url);
            });
            audioCache.clear();
            audioPrefetchEnd = 0;
            vocabulary = {};

            loadingState.style.display = 'flex';
            loadingText.textContent = refresh ? 'Creating new story with AI...' : 'Loading story...';
            storyListView.style.display = 'none';
            storyContent.style.display = 'none';
            completedState.style.display = 'none';
            continueContainer.style.display = 'none';

            // Switch to reading mode header
            headerTitle.style.display = 'none';
            createStoryBtn.style.display = 'none';
            progressContainer.style.display = 'block';
            progressText.style.display = 'block';
            if (audioToggleBtn) audioToggleBtn.style.display = 'inline-flex';
            if (refreshTranslationsBtn) refreshTranslationsBtn.style.display = 'inline-flex';
            mainContent.classList.add('with-continue');
            isReadingMode = true;

            try {
                const url = `/story/generate?deck=${encodeURIComponent(deck)}${refresh ? '&refresh=true' : ''}`;
                const resp = await fetch(url);
                const data = await resp.json();

                if (!resp.ok) throw new Error(data.detail || 'Failed to load story');

                story = data.story;
                characters = story.characters || [];

                vocabulary = {};
                if (story.vocabulary && Object.keys(story.vocabulary).length > 0) {
                    Object.entries(story.vocabulary).forEach(([de, en]) => {
                        addToVocabulary(de, en);
                    });
                } else if (story.segments) {
                    story.segments.forEach(seg => {
                        (seg.highlight_pairs || []).forEach(pair => {
                            addToVocabulary(pair.de, pair.en);
                        });
                    });
                }

                if (!story.segments || story.segments.length === 0) {
                    throw new Error('Story has no content');
                }

                rebuildSentenceUnits();
                if (!sentenceUnits.length) {
                    throw new Error('Story has no content');
                }

                currentSegmentIndex = 0;

                // Start story immediately, prefetch audio in background
                showStory();

            } catch (error) {
                console.error('Failed to load story:', error);
                loadingState.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state__emoji">ðŸ˜•</div>
                        <h3 class="empty-state__title">Failed to load story</h3>
                        <p class="empty-state__text">${error.message}</p>
                        <button class="continue-btn" onclick="loadStory('${deck}', true)">Try Again</button>
                        <button class="btn-secondary" onclick="loadStoryList()">Back to Stories</button>
                    </div>
                `;
            }
        }

        async function loadStoryWithTopic(topic, level) {
            // Generate a unique ID for this story
            const storyId = 'custom_' + Date.now();
            currentDeck = storyId;

            // Clear previous caches
            audioCache.forEach(url => {
                if (url.startsWith('blob:')) URL.revokeObjectURL(url);
            });
            audioCache.clear();
            audioPrefetchEnd = 0;
            vocabulary = {};

            loadingState.style.display = 'flex';
            loadingText.textContent = 'Creating your story with AI...';
            storyListView.style.display = 'none';
            storyContent.style.display = 'none';
            completedState.style.display = 'none';
            continueContainer.style.display = 'none';

            // Switch to reading mode header
            headerTitle.style.display = 'none';
            createStoryBtn.style.display = 'none';
            progressContainer.style.display = 'block';
            progressText.style.display = 'block';
            if (audioToggleBtn) audioToggleBtn.style.display = 'inline-flex';
            if (refreshTranslationsBtn) refreshTranslationsBtn.style.display = 'inline-flex';
            mainContent.classList.add('with-continue');
            isReadingMode = true;

            try {
                const resp = await fetch('/story/generate/custom', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ topic: topic, story_id: storyId, level: level || 'A2' })
                });
                const data = await resp.json();

                if (!resp.ok) throw new Error(data.detail || 'Failed to create story');

                story = data.story;
                currentDeck = data.story_id || storyId;
                characters = story.characters || [];

                vocabulary = {};
                if (story.vocabulary && Object.keys(story.vocabulary).length > 0) {
                    Object.entries(story.vocabulary).forEach(([de, en]) => {
                        addToVocabulary(de, en);
                    });
                } else if (story.segments) {
                    story.segments.forEach(seg => {
                        (seg.highlight_pairs || []).forEach(pair => {
                            addToVocabulary(pair.de, pair.en);
                        });
                    });
                }

                if (!story.segments || story.segments.length === 0) {
                    throw new Error('Story has no content');
                }

                rebuildSentenceUnits();
                if (!sentenceUnits.length) {
                    throw new Error('Story has no content');
                }

                currentSegmentIndex = 0;

                // Start story immediately, prefetch audio in background
                showStory();

                // Reload story list in background to show the new story
                fetch('/stories/list').then(r => r.json()).then(data => {
                    allStories = data.stories || [];
                }).catch(() => { });

            } catch (error) {
                console.error('Failed to create story:', error);
                loadingState.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state__emoji">ðŸ˜•</div>
                        <h3 class="empty-state__title">Failed to create story</h3>
                        <p class="empty-state__text">${error.message}</p>
                        <button class="continue-btn" onclick="openCreateModal()">Try Again</button>
                        <button class="btn-secondary" onclick="loadStoryList()">Back to Stories</button>
                    </div>
                `;
            }
        }

        async function loadStoryFromText(text, level) {
            const storyId = 'text_' + Date.now();
            currentDeck = storyId;

            audioCache.forEach(url => {
                if (url.startsWith('blob:')) URL.revokeObjectURL(url);
            });
            audioCache.clear();
            audioPrefetchEnd = 0;
            vocabulary = {};

            loadingState.style.display = 'flex';
            loadingText.textContent = 'Processing your story...';
            storyListView.style.display = 'none';
            storyContent.style.display = 'none';
            completedState.style.display = 'none';
            continueContainer.style.display = 'none';

            headerTitle.style.display = 'none';
            createStoryBtn.style.display = 'none';
            progressContainer.style.display = 'block';
            progressText.style.display = 'block';
            if (audioToggleBtn) audioToggleBtn.style.display = 'inline-flex';
            if (refreshTranslationsBtn) refreshTranslationsBtn.style.display = 'inline-flex';
            mainContent.classList.add('with-continue');
            isReadingMode = true;

            try {
                const resp = await fetch('/story/from_text', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: text, story_id: storyId, level: level || 'A2' })
                });
                const data = await resp.json();

                if (!resp.ok) throw new Error(data.detail || 'Failed to process story');

                story = data.story;
                currentDeck = data.story_id || storyId;
                characters = story.characters || [];

                vocabulary = {};
                if (story.vocabulary && Object.keys(story.vocabulary).length > 0) {
                    Object.entries(story.vocabulary).forEach(([de, en]) => {
                        addToVocabulary(de, en);
                    });
                } else if (story.segments) {
                    story.segments.forEach(seg => {
                        (seg.highlight_pairs || []).forEach(pair => {
                            addToVocabulary(pair.de, pair.en);
                        });
                    });
                }

                if (!story.segments || story.segments.length === 0) {
                    throw new Error('Story has no content');
                }

                rebuildSentenceUnits();
                if (!sentenceUnits.length) {
                    throw new Error('Story has no content');
                }

                currentSegmentIndex = 0;
                showStory();
                ensureAudioPrefetchAround(0);
            } catch (error) {
                console.error('Failed to process story:', error);
                loadingState.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state__emoji">ðŸ˜•</div>
                        <h3 class="empty-state__title">Failed to process story</h3>
                        <p class="empty-state__text">${error.message}</p>
                        <button class="btn-secondary" onclick="loadStoryList()">Back to Stories</button>
                    </div>
                `;
            }
        }

        async function loadStoryFromSrt(file) {
            if (!file) return;

            audioCache.forEach(url => {
                if (url.startsWith('blob:')) URL.revokeObjectURL(url);
            });
            audioCache.clear();
            audioPrefetchEnd = 0;
            vocabulary = {};

            loadingState.style.display = 'flex';
            loadingText.textContent = 'Loading subtitles...';
            storyListView.style.display = 'none';
            storyContent.style.display = 'none';
            completedState.style.display = 'none';
            continueContainer.style.display = 'none';

            headerTitle.style.display = 'none';
            createStoryBtn.style.display = 'none';
            progressContainer.style.display = 'block';
            progressText.style.display = 'block';
            if (audioToggleBtn) audioToggleBtn.style.display = 'inline-flex';
            if (refreshTranslationsBtn) refreshTranslationsBtn.style.display = 'inline-flex';
            mainContent.classList.add('with-continue');
            isReadingMode = true;

            try {
                const form = new FormData();
                form.append('file', file);

                const resp = await fetch('/story/upload_srt', {
                    method: 'POST',
                    body: form
                });
                const data = await resp.json();

                if (!resp.ok) throw new Error(data.detail || 'Failed to load subtitles');

                story = data.story;
                currentDeck = data.story_id || 'srt_' + Date.now();
                characters = story.characters || [];

                vocabulary = {};
                if (story.vocabulary && Object.keys(story.vocabulary).length > 0) {
                    Object.entries(story.vocabulary).forEach(([de, en]) => {
                        addToVocabulary(de, en);
                    });
                }

                if (!story.segments || story.segments.length === 0) {
                    throw new Error('Story has no content');
                }

                rebuildSentenceUnits();
                if (!sentenceUnits.length) {
                    throw new Error('Story has no content');
                }

                currentSegmentIndex = 0;
                showStory();
                ensureAudioPrefetchAround(0);
            } catch (error) {
                console.error('Failed to load subtitles:', error);
                loadingState.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state__emoji">ðŸ˜•</div>
                        <h3 class="empty-state__title">Failed to load subtitles</h3>
                        <p class="empty-state__text">${error.message}</p>
                        <button class="btn-secondary" onclick="loadStoryList()">Back to Stories</button>
                    </div>
                `;
            } finally {
                if (srtFileInput) srtFileInput.value = '';
            }
        }

        // â”€â”€ Tab switching for create modal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function switchCreateTab(tab) {
            const tabs = { ai: 'tabAI', text: 'tabText', yt: 'tabYT' };
            const contents = { ai: 'tabContentAI', text: 'tabContentText', yt: 'tabContentYT' };
            Object.keys(tabs).forEach(k => {
                const btn = document.getElementById(tabs[k]);
                const content = document.getElementById(contents[k]);
                if (!btn || !content) return;
                const active = k === tab;
                btn.style.background = active ? 'var(--accent)' : 'var(--card-bg)';
                btn.style.color = active ? '#fff' : 'var(--text)';
                btn.style.borderColor = active ? 'var(--accent)' : 'var(--card-border)';
                content.style.display = active ? 'block' : 'none';
            });
        }

        // â”€â”€ YouTube subtitle loader â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        async function loadStoryFromYoutube(url, level) {
            const ytError = document.getElementById('ytError');
            if (ytError) { ytError.style.display = 'none'; ytError.textContent = ''; }

            audioCache.forEach(u => { if (u.startsWith('blob:')) URL.revokeObjectURL(u); });
            audioCache.clear();
            audioPrefetchEnd = 0;
            vocabulary = {};

            // Close modal + show loading
            createModal.classList.remove('visible');
            loadingState.style.display = 'flex';
            loadingText.textContent = 'Extracting subtitles from YouTubeâ€¦';
            storyListView.style.display = 'none';
            storyContent.style.display = 'none';
            completedState.style.display = 'none';
            continueContainer.style.display = 'none';

            headerTitle.style.display = 'none';
            createStoryBtn.style.display = 'none';
            progressContainer.style.display = 'block';
            progressText.style.display = 'block';
            if (audioToggleBtn) audioToggleBtn.style.display = 'inline-flex';
            if (refreshTranslationsBtn) refreshTranslationsBtn.style.display = 'inline-flex';
            mainContent.classList.add('with-continue');
            isReadingMode = true;

            try {
                const resp = await fetch('/story/from_youtube', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url, level: level || 'A2' })
                });
                const data = await resp.json();
                if (!resp.ok) throw new Error(data.detail || 'Failed to load YouTube subtitles');

                story = data.story;
                currentDeck = data.story_id || 'yt_' + Date.now();
                characters = story.characters || [];

                vocabulary = {};
                if (story.vocabulary && Object.keys(story.vocabulary).length > 0) {
                    Object.entries(story.vocabulary).forEach(([de, en]) => addToVocabulary(de, en));
                } else if (story.segments) {
                    story.segments.forEach(seg => {
                        (seg.highlight_pairs || []).forEach(pair => addToVocabulary(pair.de, pair.en));
                    });
                }

                if (!story.segments || story.segments.length === 0) throw new Error('No subtitles found');

                rebuildSentenceUnits();
                if (!sentenceUnits.length) throw new Error('No content to display');

                currentSegmentIndex = 0;
                showStory();
                ensureAudioPrefetchAround(0);

                // Refresh story list in background
                fetch('/stories/list').then(r => r.json()).then(d => { allStories = d.stories || []; }).catch(() => { });

            } catch (error) {
                console.error('YouTube load failed:', error);
                loadingState.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state__emoji">ðŸ˜•</div>
                        <h3 class="empty-state__title">Couldn't load subtitles</h3>
                        <p class="empty-state__text">${error.message}</p>
                        <button class="continue-btn" onclick="openCreateModal('yt')">Try Again</button>
                        <button class="btn-secondary" onclick="loadStoryList()">Back to Stories</button>
                    </div>
                `;
            }
        }

        async function prefetchAudioFrom(startIndex) {
            if (!sentenceUnits || !sentenceUnits.length) return;
            const totalUnits = sentenceUnits.length;
            if (startIndex >= totalUnits) return;

            const end = Math.min(startIndex + AUDIO_PREFETCH_BATCH, totalUnits);
            const texts = new Set();
            for (let i = startIndex; i < end; i++) {
                const unit = sentenceUnits[i];
                const text = (unit.text_de || '').trim();
                if (text && !audioCache.has(text)) {
                    texts.add(text);
                }
            }

            const promises = Array.from(texts).map(async (text) => {
                try {
                    const url = `/story/audio?deck=${encodeURIComponent(currentDeck)}&text=${encodeURIComponent(text)}`;
                    const resp = await fetch(url);
                    if (resp.ok) {
                        const blob = await resp.blob();
                        const objUrl = URL.createObjectURL(blob);
                        audioCache.set(text, objUrl);
                    }
                } catch (e) {
                    console.warn('Failed to prefetch audio:', text, e);
                }
            });

            await Promise.allSettled(promises);
            audioPrefetchEnd = end;
        }

        function ensureAudioPrefetchAround(index) {
            if (!sentenceUnits || !sentenceUnits.length) return;
            const total = sentenceUnits.length;
            if (total === 0) return;
            if (audioPrefetchEnd === 0) {
                prefetchAudioFrom(0);
                return;
            }
            if (index >= audioPrefetchEnd - 2 && audioPrefetchEnd < total) {
                prefetchAudioFrom(audioPrefetchEnd);
            }
        }

        function showStory() {
            loadingState.style.display = 'none';
            storyContent.style.display = 'block';
            completedState.style.display = 'none';
            continueContainer.style.display = 'block';

            storyTitle.textContent = story.title_de || 'Geschichte';
            storySubtitle.textContent = story.title_en || 'Story';

            const level = story.level || story.Level || story.cefr_level || null;
            if (level) {
                storyLevelBadge.textContent = level;
                storyLevelBadge.style.display = 'inline-flex';
            } else {
                storyLevelBadge.style.display = 'none';
            }

            segmentsContainer.innerHTML = '';
            renderedSegmentCount = 0;
            continueBtn.textContent = 'Continue';
            continueBtn.disabled = true;
            if (sentenceUnits.length > 0) {
                showSegmentAt(0);
            }
        }

        function showSegmentAt(index) {
            if (!sentenceUnits || index < 0 || index >= sentenceUnits.length) return;
            if (!Number.isInteger(renderedSegmentCount) || renderedSegmentCount < 0) {
                renderedSegmentCount = 0;
            }
            while (renderedSegmentCount <= index) {
                const shouldAutoPlay = renderedSegmentCount === index;
                renderSegment(renderedSegmentCount, shouldAutoPlay);
                renderedSegmentCount += 1;
            }
            currentSegmentIndex = index;
            updateProgress();
            ensureAudioPrefetchAround(index);
            const target = segmentsContainer.querySelector(`.story-segment[data-index="${index}"]`);
            if (target) {
                target.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        function renderSegment(index, shouldAutoPlay) {
            const unit = sentenceUnits[index];
            if (!unit) return;
            const segment = story && story.segments ? (story.segments[unit.segmentIndex] || {}) : {};

            const div = document.createElement('div');
            div.className = `story-segment story-segment-enter segment-${unit.type || segment.type || 'narration'}`;
            div.dataset.index = index;

            let html = '';
            const speakerName = unit.speaker || segment.speaker;
            const isDialogueWithSpeaker = (unit.type || segment.type) === 'dialogue' && speakerName && speakerName !== 'narrator';

            if (isDialogueWithSpeaker) {
                html += `
                    <div class="segment-speaker">
                        <div class="speaker-avatar ${getAvatarClass(speakerName)}">${getInitial(speakerName)}</div>
                        <span class="speaker-name">${speakerName}</span>
                        <button class="audio-btn" data-text="${(unit.text_de || '').replace(/"/g, '&quot;')}">
                            <span class="material-symbols-outlined">volume_up</span>
                        </button>
                    </div>
                `;
            }

            let colorMapDe = segment._colorMapDe;
            let colorMapEn = segment._colorMapEn;

            if (!colorMapDe || !colorMapEn) {
                const highlightPairs = segment.highlight_pairs || [];
                colorMapDe = {};
                colorMapEn = {};

                if (highlightPairs.length > 0) {
                    const textDeLower = (segment.text_de || '').toLowerCase();
                    const textEnLower = (segment.text_en || '').toLowerCase();

                    highlightPairs.forEach(pair => {
                        const deWord = (pair.de || '').toLowerCase().trim();
                        const enWord = (pair.en || '').toLowerCase().trim();

                        const deExists = deWord && textDeLower.includes(deWord);
                        const enExists = enWord && textEnLower.includes(enWord);

                        if (deExists && enExists) {
                            colorMapDe[deWord] = pair.color;
                            colorMapEn[enWord] = pair.color;
                        }
                    });
                } else if (segment.highlight_words && segment.highlight_words.length > 0) {
                    segment.highlight_words.forEach((word, idx) => {
                        colorMapDe[word.toLowerCase()] = idx % 16;
                    });
                }

                segment._colorMapDe = colorMapDe;
                segment._colorMapEn = colorMapEn;
            }

            const cachedDe = unit._highlightedTextDe;
            const cachedEn = unit._highlightedTextEn;
            const baseTextDe = unit.text_de || '';
            const baseTextEn = unit.text_en || '';
            const textDe = cachedDe || (unit._highlightedTextDe = highlightWordsInText(baseTextDe, colorMapDe));
            const textEn = cachedEn || (unit._highlightedTextEn = highlightWordsInText(baseTextEn, colorMapEn));

            if (isDialogueWithSpeaker) {
                html += `
                    <div class="segment-content">
                        <div>
                            <p class="segment-text">${textDe}</p>
                            <p class="segment-translation visible">${textEn}</p>
                        </div>
                    </div>
                `;
            } else {
                html += `
                    <div class="segment-content">
                        <button class="audio-btn" data-text="${(unit.text_de || '').replace(/"/g, '&quot;')}">
                            <span class="material-symbols-outlined">volume_up</span>
                        </button>
                        <div>
                            <p class="segment-text">${textDe}</p>
                            <p class="segment-translation visible">${textEn}</p>
                        </div>
                    </div>
                `;
            }

            div.innerHTML = html;
            segmentsContainer.appendChild(div);

            requestAnimationFrame(() => {
                div.classList.remove('story-segment-enter');
            });

            div.querySelector('.audio-btn').addEventListener('click', (e) => {
                const text = e.currentTarget.dataset.text;
                playAudio(text);
            });

            if (shouldAutoPlay) {
                setTimeout(() => playAudio(unit.text_de), 300);
            }

            continueBtn.textContent = 'Continue';
            continueBtn.disabled = false;
        }

        // Function to highlight words/phrases using AI-provided color map
        function highlightWordsInText(text, colorMap) {
            if (!text || Object.keys(colorMap).length === 0) return text;

            let result = text;

            // Sort by phrase length (longer first) to match "zu viel" before "zu"
            const sortedPhrases = Object.keys(colorMap).sort((a, b) => b.length - a.length);

            // Replace each phrase with a placeholder, then restore with highlighting
            const placeholders = [];

            sortedPhrases.forEach((phrase, idx) => {
                const colorIndex = colorMap[phrase];
                // Create regex that matches the phrase case-insensitively, with word boundaries
                const escaped = phrase.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const regex = new RegExp(`(^|[\\s.,!?;:'"â€ž"Â»Â«()])${escaped}([\\s.,!?;:'"â€ž"Â»Â«()]|$)`, 'gi');

                result = result.replace(regex, (match, before, after) => {
                    // Find the actual matched phrase (preserving original case)
                    const actualPhrase = match.substring(before.length, match.length - after.length);
                    const placeholder = `__HIGHLIGHT_${idx}__`;
                    placeholders.push({
                        placeholder,
                        html: `<span class="word-highlight highlight-${colorIndex} tappable-word" data-word="${actualPhrase}">${actualPhrase}</span>`
                    });
                    return before + placeholder + after;
                });
            });

            // Make remaining words tappable
            result = result.split(/(\s+|__HIGHLIGHT_\d+__)/).map(part => {
                if (!part.trim() || part.startsWith('__HIGHLIGHT_')) return part;

                // Skip if it's punctuation only
                const cleanPart = part.replace(/[.,!?;:'"â€ž"Â»Â«()]/g, '');
                if (!cleanPart) return part;

                // Extract punctuation
                const match = part.match(/^([.,!?;:'"â€ž"Â»Â«()]*)(.+?)([.,!?;:'"â€ž"Â»Â«()]*)$/);
                const prefix = match ? match[1] : '';
                const core = match ? match[2] : part;
                const suffix = match ? match[3] : '';

                return `${prefix}<span class="tappable-word" data-word="${core}">${core}</span>${suffix}`;
            }).join('');

            // Restore placeholders with actual HTML
            placeholders.forEach(({ placeholder, html }) => {
                result = result.replace(placeholder, html);
            });

            return result;
        }

        function updateProgress() {
            if (!sentenceUnits || !sentenceUnits.length) return;
            const total = sentenceUnits.length;
            const current = currentSegmentIndex + 1;
            const progress = (current / total) * 100;
            progressBar.style.width = `${progress}%`;
            progressText.textContent = `${current}/${total}`;
        }

        function showCompleted() {
            storyContent.style.display = 'none';
            continueContainer.style.display = 'none';
            completedState.style.display = 'block';
            progressBar.style.width = '100%';
        }

        if (srtFileInput) {
            srtFileInput.addEventListener('change', (e) => {
                const file = e.target.files && e.target.files[0];
                if (file) {
                    loadStoryFromSrt(file);
                }
            });
        }

        function updateAudioToggleUI() {
            if (!audioToggleBtn || !audioToggleIcon) return;
            if (isAudioEnabled) {
                audioToggleBtn.classList.remove('audio-off');
                audioToggleIcon.textContent = 'volume_up';
            } else {
                audioToggleBtn.classList.add('audio-off');
                audioToggleIcon.textContent = 'volume_off';
            }
        }

        if (refreshTranslationsBtn) {
            refreshTranslationsBtn.addEventListener('click', refreshTranslations);
        }

        if (audioToggleBtn) {
            audioToggleBtn.addEventListener('click', () => {
                isAudioEnabled = !isAudioEnabled;
                if (!isAudioEnabled) {
                    audioPlayer.pause();
                }
                updateAudioToggleUI();
            });
            updateAudioToggleUI();
        }


        async function playAudio(text) {
            if (!text || !isAudioEnabled) return;
            try {
                audioPlayer.pause();
                audioPlayer.currentTime = 0;

                // Use prefetched audio if available, otherwise fetch from server
                if (audioCache.has(text)) {
                    audioPlayer.src = audioCache.get(text);
                } else {
                    audioPlayer.src = `/story/audio?deck=${encodeURIComponent(currentDeck)}&text=${encodeURIComponent(text)}`;
                }

                await audioPlayer.play();
            } catch (error) {
                console.warn('Audio failed:', error);
            }
        }

        // Create story modal
        function openCreateModal(tab) {
            storyTopicInput.value = '';
            if (storyTextInput) storyTextInput.value = '';
            storyLevelSelect.value = 'A2';
            createModal.classList.add('visible');
            switchCreateTab(tab || 'ai');
            if (!tab || tab === 'ai') {
                setTimeout(() => storyTopicInput.focus(), 100);
            } else if (tab === 'yt') {
                setTimeout(() => { const el = document.getElementById('ytUrlInput'); if (el) el.focus(); }, 100);
            }
        }

        function closeCreateModal() {
            createModal.classList.remove('visible');
        }

        async function createStoryWithTopic(topic) {
            closeCreateModal();
            const level = storyLevelSelect.value || 'A2';
            await loadStoryWithTopic(topic, level);
        }

        async function createStoryFromText(text) {
            closeCreateModal();
            const level = (document.getElementById('textLevelSelect') || storyLevelSelect).value || 'A2';
            await loadStoryFromText(text, level);
        }

        async function createRandomStory() {
            const randomTopics = [
                'a trip to the airport',
                'ordering food at a restaurant',
                'shopping at a market',
                'meeting a new friend',
                'a day at school',
                'visiting a doctor',
                'a birthday party',
                'traveling by train',
                'a picnic in the park',
                'cooking dinner at home',
                'going to the cinema',
                'a job interview',
                'vacation at the beach',
                'learning to drive',
                'moving to a new apartment'
            ];
            const randomTopic = randomTopics[Math.floor(Math.random() * randomTopics.length)];
            const level = storyLevelSelect.value || 'A2';
            closeCreateModal();
            await loadStoryWithTopic(randomTopic, level);
        }

        segmentsContainer.addEventListener('click', (e) => {
            const tappable = e.target.closest('.tappable-word');
            if (!tappable) return;

            e.stopPropagation();
            const word = tappable.dataset.word;
            const cleanWord = word.toLowerCase().replace(/[.,!?;:'"â€ž"Â»Â«()]/g, '');

            const segmentEl = tappable.closest('.story-segment');
            let segment = null;
            if (segmentEl && sentenceUnits && Array.isArray(sentenceUnits) && story && Array.isArray(story.segments)) {
                const idx = parseInt(segmentEl.dataset.index, 10);
                const unit = sentenceUnits[idx];
                if (unit && typeof unit.segmentIndex === 'number') {
                    segment = story.segments[unit.segmentIndex];
                }
            }

            let meaning = '';

            // 1) Prefer highlight_pairs via color mapping
            if (segment && Array.isArray(segment.highlight_pairs)) {
                const classes = (tappable.className || '').split(/\s+/);
                const colorClass = classes.find(c => c.startsWith('highlight-'));
                if (colorClass) {
                    const colorIndex = parseInt(colorClass.replace('highlight-', ''), 10);
                    const pair = segment.highlight_pairs.find(p => {
                        if (!p) return false;
                        const c = typeof p.color === 'number' ? p.color : parseInt(p.color, 10);
                        return c === colorIndex;
                    });
                    if (pair && pair.en) {
                        meaning = pair.en;
                    }
                }
            }

            // 1.5) Check full_vocabulary if available (generated by AI)
            if (!meaning && segment && segment.full_vocabulary) {
                // Try various forms: exact, cleaned (preserve case), cleaned (lowercase)
                const rawClean = word.replace(/[.,!?;:'"â€ž"Â»Â«()]/g, '');
                meaning = segment.full_vocabulary[word] ||
                    segment.full_vocabulary[rawClean] ||
                    segment.full_vocabulary[cleanWord] ||
                    '';

                // If still not found, try case-insensitive lookup in full_vocabulary keys
                if (!meaning) {
                    const target = cleanWord;
                    const foundKey = Object.keys(segment.full_vocabulary).find(k =>
                        k.toLowerCase().replace(/[.,!?;:'"â€ž"Â»Â«()]/g, '') === target
                    );
                    if (foundKey) {
                        meaning = segment.full_vocabulary[foundKey];
                    }
                }
            }

            // 2) Fall back to global vocabulary and common words
            if (!meaning) {
                meaning = vocabulary[cleanWord] || vocabulary[word.toLowerCase()] || commonWords[cleanWord] || '';
            }

            // 3) Last resort: show a short placeholder, not the whole sentence
            if (!meaning) {
                meaning = 'No translation available';
            }

            showTooltip(tappable, meaning);
        });

        // Hide tooltip when clicking anywhere else
        document.addEventListener('click', (e) => {
            // Don't hide if clicking on a tappable word (handled above)
            if (!e.target.closest('.tappable-word') && !e.target.closest('.tooltip')) {
                hideTooltip();
            }
        });

        function showTooltip(element, text) {
            const rect = element.getBoundingClientRect();
            tooltip.textContent = text;
            tooltip.style.left = `${rect.left + rect.width / 2}px`;
            tooltip.style.top = `${rect.top - 8}px`;
            tooltip.style.transform = 'translate(-50%, -100%)';
            tooltip.classList.add('visible');
            // No timeout - stays visible until user clicks elsewhere
        }

        function hideTooltip() {
            tooltip.classList.remove('visible');
        }

        // Refresh translations for current story
        async function refreshTranslations() {
            if (!currentDeck) return;
            const btn = refreshTranslationsBtn;
            if (btn) {
                btn.disabled = true;
                btn.querySelector('.material-symbols-outlined').style.animation = 'spin 1s linear infinite';
            }
            try {
                const level = (story && story.level) || 'A2';
                const resp = await fetch('/story/retranslate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ story_id: currentDeck, level })
                });
                const data = await resp.json();
                if (!resp.ok) throw new Error(data.detail || 'Refresh failed');

                // Swap in refreshed story and restart from current position
                const savedIndex = currentSegmentIndex;
                story = data.story;
                characters = story.characters || [];

                vocabulary = {};
                if (story.vocabulary && Object.keys(story.vocabulary).length > 0) {
                    Object.entries(story.vocabulary).forEach(([de, en]) => addToVocabulary(de, en));
                } else if (story.segments) {
                    story.segments.forEach(seg => (seg.highlight_pairs || []).forEach(p => addToVocabulary(p.de, p.en)));
                }

                // Clear old renders, rebuild, restart from same position
                segmentsContainer.innerHTML = '';
                renderedSegmentCount = 0;
                audioCache.forEach(u => { if (u.startsWith('blob:')) URL.revokeObjectURL(u); });
                audioCache.clear();
                audioPrefetchEnd = 0;

                rebuildSentenceUnits();
                const newIndex = Math.min(savedIndex, sentenceUnits.length - 1);
                showSegmentAt(Math.max(0, newIndex));
            } catch (err) {
                console.error('Refresh failed:', err);
                alert('Refresh failed: ' + err.message);
            } finally {
                if (btn) {
                    btn.disabled = false;
                    btn.querySelector('.material-symbols-outlined').style.animation = '';
                }
            }
        }

        // Events
        backBtn.addEventListener('click', () => {
            if (isReadingMode) {
                loadStoryList();
                history.replaceState(null, '', '/story');
            } else {
                history.back() || (location.href = '/');
            }
        });

        createStoryBtn.addEventListener('click', openCreateModal);
        createModalBackdrop.addEventListener('click', closeCreateModal);
        createModalClose.addEventListener('click', closeCreateModal);
        createStorySubmit.addEventListener('click', () => {
            const topic = storyTopicInput.value.trim();
            if (topic) {
                createStoryWithTopic(topic);
            } else {
                storyTopicInput.focus();
                storyTopicInput.style.borderColor = 'var(--danger)';
                setTimeout(() => storyTopicInput.style.borderColor = '', 1500);
            }
        });
        randomStoryBtn.addEventListener('click', createRandomStory);
        storyTopicInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const topic = storyTopicInput.value.trim();
                if (topic) createStoryWithTopic(topic);
            }
        });

        // Text tab submit
        const submitTextStoryBtn = document.getElementById('submitTextStoryBtn');
        if (submitTextStoryBtn) {
            submitTextStoryBtn.addEventListener('click', () => {
                const text = storyTextInput ? storyTextInput.value.trim() : '';
                if (text) {
                    createStoryFromText(text);
                } else {
                    storyTextInput.focus();
                    storyTextInput.style.borderColor = 'var(--danger)';
                    setTimeout(() => storyTextInput.style.borderColor = '', 1500);
                }
            });
        }

        // YouTube tab submit
        const submitYTBtn = document.getElementById('submitYTBtn');
        if (submitYTBtn) {
            submitYTBtn.addEventListener('click', () => {
                const url = (document.getElementById('ytUrlInput') || {}).value?.trim();
                const level = (document.getElementById('ytLevelSelect') || {}).value || 'A2';
                const ytError = document.getElementById('ytError');
                if (!url) {
                    if (ytError) { ytError.textContent = 'Please enter a YouTube URL.'; ytError.style.display = 'block'; }
                    return;
                }
                loadStoryFromYoutube(url, level);
            });
        }

        // YouTube button in list header opens modal on YouTube tab
        const youtubeLinkBtn = document.getElementById('youtubeLinkBtn');
        if (youtubeLinkBtn) {
            youtubeLinkBtn.addEventListener('click', () => openCreateModal('yt'));
        }

        // SRT file input
        if (srtFileInput) {
            srtFileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) loadStoryFromSrt(file);
            });
        }

        // Action popup events
        actionPopupBackdrop.addEventListener('click', closeActionPopup);
        cancelActionBtn.addEventListener('click', closeActionPopup);
        deleteStoryBtn.addEventListener('click', deleteSelectedStory);

        continueBtn.addEventListener('click', () => {
            if (!sentenceUnits || !sentenceUnits.length) return;
            const next = currentSegmentIndex + 1;
            if (next >= sentenceUnits.length) {
                showCompleted();
            } else {
                showSegmentAt(next);
            }
        });

        restartBtn.addEventListener('click', () => {
            currentSegmentIndex = 0;
            renderedSegmentCount = 0;
            segmentsContainer.innerHTML = '';
            showSegmentAt(0);
        });

        backToListBtn.addEventListener('click', () => {
            loadStoryList();
            history.replaceState(null, '', '/story');
        });

        // Start
        init();
    </script>
</body>

</html>