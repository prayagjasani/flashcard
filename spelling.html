<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta name="theme-color" content="#ffffff" />
    <meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: dark)" />
    <meta name="msapplication-navbutton-color" content="#ffffff" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <title>Spelling Practice</title>
    <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
    <link href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;500;600;700&display=swap" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet" />
    <script id="tailwind-config">
        tailwind.config = {
            darkMode: "class",
            theme: {
                extend: {
                    colors: {
                        primary: "#007AFF",
                        "background-light": "#F9F9F9",
                        "background-dark": "#101922",
                        "card-light": "#FFFFFF",
                        "card-dark": "#19242E",
                        "text-primary-light": "#333333",
                        "text-primary-dark": "#E5E7EB",
                        "text-secondary-light": "#8E8E93",
                        "text-secondary-dark": "#92adc9",
                        destructive: "#FF3B30"
                    },
                    fontFamily: {
                        display: [
                            ["Lexend", "sans-serif"]
                        ]
                    },
                    borderRadius: {
                        DEFAULT: "0.25rem",
                        lg: "0.5rem",
                        xl: "0.75rem",
                        full: "9999px"
                    }
                }
            }
        }
    </script>
    <style>
        .material-symbols-outlined {
            font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24
        }
        
        body {
            min-height: max(884px, 100dvh)
        }
        
        .loading-overlay {
            position: fixed;
            inset: 0;
            z-index: 5;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, .6);
            transition: opacity .2s ease
        }
        
        .loading-overlay.is-active {
            display: flex
        }
        
        .loading-dots {
            display: flex;
            gap: 8px;
            color: #8E8E93
        }
        
        .loading-dots span {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            opacity: .5;
            animation: dotPulse 1000ms infinite ease-in-out;
            will-change: transform, opacity
        }
        
        .loading-dots span:nth-child(2) {
            animation-delay: 150ms
        }
        
        .loading-dots span:nth-child(3) {
            animation-delay: 300ms
        }
        
        @keyframes dotPulse {
            0% {
                transform: scale(1);
                opacity: .35
            }
            50% {
                transform: scale(1.25);
                opacity: 1
            }
            100% {
                transform: scale(1);
                opacity: .35
            }
        }
        
        @media (prefers-color-scheme: dark) {
            .loading-dots {
                color: #92adc9
            }
            .loading-overlay {
                background: rgba(0, 0, 0, .6)
            }
        }
        
        .practice-card {
            transition: none
        }
        
        .practice-card:hover {
            transform: none;
            box-shadow: none
        }
        
        @media (prefers-color-scheme: dark) {
            .practice-card:hover {
                box-shadow: none
            }
        }
        
        .inline-tooltip {
            position: fixed;
            left: 0;
            top: 0;
            transform: translate(-50%, 0);
            padding: 8px 12px;
            border-radius: 12px;
            background: #eef0f4;
            border: 1px solid #e5e7eb;
            color: #333;
            z-index: 1000;
            box-shadow: none
        }
        
        .inline-tooltip:after {
            content: "";
            position: absolute;
            bottom: -7px;
            left: 50%;
            transform: translateX(-50%);
            border-left: 7px solid transparent;
            border-right: 7px solid transparent;
            border-top: 7px solid #eef0f4
        }
        
        @media (prefers-color-scheme: dark) {
            .inline-tooltip {
                background: #1f2937;
                border-color: #374151;
                color: #e5e7eb
            }
            .inline-tooltip:after {
                border-top-color: #1f2937
            }
        }
    </style>
</head>

<body class="bg-background-light dark:bg-background-dark font-display">
    <div class="relative flex min-h-screen w-full flex-col">
        <header class="sticky top-0 z-10 bg-background-light/80 dark:bg-background-dark/80 backdrop-blur-sm border-b border-slate-200 dark:border-slate-800">
            <div class="mx-auto max-w-md px-3 py-2 flex items-center gap-2">
                <button id="backBtn" class="flex h-8 w-8 items-center justify-center rounded-full text-text-primary-light dark:text-text-primary-dark"><span class="material-symbols-outlined text-xl">close</span></button>
                <div class="flex-1 text-center text-sm font-semibold text-text-secondary-light dark:text-text-secondary-dark" id="progressText">0/0</div>
                <button id="homeBtn" class="flex h-8 w-8 items-center justify-center rounded-full text-text-primary-light dark:text-text-primary-dark" aria-label="Home"><span class="material-symbols-outlined text-xl">home</span></button>
            </div>
        </header>

        <div id="globalLoader" class="loading-overlay" aria-hidden="true">
            <div class="loading-dots"><span></span><span></span><span></span></div>
        </div>

        <main class="mx-auto max-w-md p-4 w-full">
            <section class="mb-4">
                <label for="deckSelect" class="block text-xs font-semibold text-text-secondary-light dark:text-text-secondary-dark">Deck</label>
                <select id="deckSelect" class="mt-1 w-full rounded-lg border border-slate-300 dark:border-slate-700 bg-card-light dark:bg-card-dark text-text-primary-light dark:text-text-primary-dark"></select>
            </section>

            <section class="practice-card rounded-xl bg-card-light dark:bg-card-dark p-6 text-center">
                <div class="text-2xl font-bold text-text-primary-light dark:text-text-primary-dark cursor-pointer" id="englishWord">Select a deck</div>
                <div id="deTooltip" class="inline-tooltip hidden"></div>
                <div class="mt-4 flex items-center justify-center">
                    <button id="playAudioBtn" class="h-10 w-10 rounded-full bg-primary text-white flex items-center justify-center"><span class="material-symbols-outlined">volume_up</span></button>
                </div>
                <div class="mt-6 text-left">
                    <label for="spellingInput" class="block text-sm font-semibold text-text-secondary-light dark:text-text-secondary-dark">Spelling</label>
                    <input id="spellingInput" type="text" placeholder="Type the word here..." class="mt-2 w-full rounded-lg border border-slate-300 dark:border-slate-700 bg-slate-100 dark:bg-slate-800/60 text-text-primary-light dark:text-text-primary-dark px-3 py-2" />
                </div>
                <div class="mt-6">
                    <button id="checkBtn" class="h-11 w-full rounded-full bg-primary text-white font-semibold">Check Spelling</button>
                    <button id="nextBtn" class="mt-3 h-11 w-full rounded-full bg-slate-200 dark:bg-slate-700 font-semibold text-text-primary-light dark:text-text-primary-dark">Next</button>
                </div>
                <div id="feedback" class="mt-3 text-sm"></div>
            </section>
            <div id="completeOverlay" class="mt-6" hidden>
                <div class="card p-6 rounded-2xl">
                    <div class="mx-auto mb-4 flex items-center justify-center h-16 w-16 rounded-full bg-green-100 text-green-600">
                        <span class="material-symbols-outlined text-3xl">check_circle</span>
                    </div>
                    <div class="text-center text-xl font-bold text-text-primary-light dark:text-text-primary-dark">Great Job!</div>
                    <div class="mt-1 text-center text-green-600 dark:text-green-400">Completed â€” all words practiced!</div>
                    <div class="mt-5 grid grid-cols-2 gap-3">
                        <div class="border rounded-xl p-3 bg-white/60 dark:bg-white/10">
                            <div class="text-xs text-text-secondary-light dark:text-text-secondary-dark">Accuracy</div>
                            <div id="accValue" class="mt-1 text-lg font-semibold text-text-primary-light dark:text-text-primary-dark">100%</div>
                        </div>
                        <div class="border rounded-xl p-3 bg-white/60 dark:bg-white/10">
                            <div class="text-xs text-text-secondary-light dark:text-text-secondary-dark">Time</div>
                            <div id="timeValue" class="mt-1 text-lg font-semibold text-text-primary-light dark:text-text-primary-dark">0s</div>
                        </div>
                    </div>
                    <div class="mt-6 space-y-3">
                        <button id="continueBtn" class="w-full h-11 rounded-xl bg-green-600 text-white font-semibold">Match</button>
                        <button id="reviewBtn" class="w-full h-11 rounded-xl bg-gray-100 text-text-primary-light dark:bg-gray-800 dark:text-text-primary-dark font-semibold" disabled>Review Mistakes</button>
                        <a id="goDeckBtn" href="/" class="block text-center text-primary mt-2">Go to Deck List</a>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        const backBtn = document.getElementById('backBtn');
        const homeBtn = document.getElementById('homeBtn');
        const deckSelect = document.getElementById('deckSelect');
        const englishWord = document.getElementById('englishWord');
        const deTooltip = document.getElementById('deTooltip');
        const playAudioBtn = document.getElementById('playAudioBtn');
        const spellingInput = document.getElementById('spellingInput');
        const checkBtn = document.getElementById('checkBtn');
        const nextBtn = document.getElementById('nextBtn');
        const feedback = document.getElementById('feedback');
        const progressText = document.getElementById('progressText');
        const globalLoader = document.getElementById('globalLoader');
        const completeOverlay = document.getElementById('completeOverlay');
        const continueBtn = document.getElementById('continueBtn');
        const reviewBtn = document.getElementById('reviewBtn');
        const accValue = document.getElementById('accValue');
        const timeValue = document.getElementById('timeValue');
        const practiceCardEl = document.querySelector('.practice-card');

        function showLoader() {
            globalLoader.classList.add('is-active')
        }

        function hideLoader() {
            globalLoader.classList.remove('is-active')
        }
        const params = new URLSearchParams(location.search);
        let currentDeck = params.get('deck') || '';
        let cards = [];
        let index = 0;
        let correctCount = 0;
        const audio = new Audio();
        const audioCache = new Map();
        const audioBlobUrls = new Map();
        let autoNextTimer = null;
        let mistakes = [];
        let sessionStart = performance.now();
        let attempts = 0;
        let doneShown = false;

        function setProgress() {
            progressText.textContent = `${Math.min(index+1,cards.length)}/${cards.length}`
        }

        function renderCurrent() {
            if (!cards.length) {
                englishWord.textContent = 'Select a deck';
                spellingInput.value = '';
                feedback.textContent = '';
                closeTooltip();
                setProgress();
                clearAutoNext();
                return;
            }
            const c = cards[index];
            englishWord.textContent = c.en;
            spellingInput.value = '';
            feedback.textContent = '';
            closeTooltip();
            setProgress();
            spellingInput.focus();
            clearAutoNext();
        }
        async function loadDecks() {
            showLoader();
            try {
                const resp = await fetch('/decks');
                const list = await resp.json();
                deckSelect.innerHTML = '';
                const ph = document.createElement('option');
                ph.value = '';
                ph.textContent = 'Select a deck';
                deckSelect.appendChild(ph);
                list.forEach(d => {
                    const opt = document.createElement('option');
                    opt.value = d.name;
                    opt.textContent = d.name;
                    deckSelect.appendChild(opt);
                });
                if (currentDeck) {
                    deckSelect.value = currentDeck;
                } else {
                    deckSelect.value = '';
                }
                if (deckSelect.value) {
                    await loadCards(deckSelect.value);
                }
            } catch (e) {
                deckSelect.innerHTML = '';
                const ph = document.createElement('option');
                ph.value = '';
                ph.textContent = 'No decks';
                deckSelect.appendChild(ph);
            } finally {
                hideLoader();
            }
        }
        async function loadCards(name) {
            showLoader();
            try {
                const resp = await fetch(`/cards?deck=${encodeURIComponent(name)}`);
                const data = await resp.json();
                cards = Array.isArray(data) ? data : [];
                index = 0;
                correctCount = 0;
                mistakes = [];
                attempts = 0;
                doneShown = false;
                sessionStart = performance.now();
                completeOverlay.hidden = true;
                if (practiceCardEl) practiceCardEl.hidden = false;
                clearDeckAudio();
                hydrateAudioFromLocalStorage();
                renderCurrent();
                preloadDeckAudio(name);
            } catch (e) {
                cards = [];
                index = 0;
                correctCount = 0;
                renderCurrent();
            } finally {
                hideLoader();
            }
        }

        function playAudio() {
            if (!cards.length) {
                return;
            }
            const c = cards[index];
            const key = `audio:de:${c.de}`;
            const ls = localStorage.getItem(key);
            if (ls) {
                audio.src = ls;
            } else {
                const cached = audioCache.get(c.de);
                if (cached) {
                    audio.src = cached;
                } else {
                    audio.src = `/tts?text=${encodeURIComponent(c.de)}&lang=de`;
                }
            }
            audio.play().catch(() => {
                try {
                    const u = new SpeechSynthesisUtterance(c.de);
                    u.lang = 'de-DE';
                    speechSynthesis.speak(u);
                } catch {}
            })
        }

        function normalizeForCompare(s) {
            let out = String(s || '').toLowerCase();
            out = out.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
            out = out.replace(/\s*\([^)]*\)\s*/g, ' ');
            out = out.replace(/\s*\[[^\]]*\]\s*/g, ' ');
            out = out.replace(/\s*\{[^}]*\}\s*/g, ' ');
            out = out.replace(/\s+/g, ' ').trim();
            return out;
        }

        function stripOptionalForDisplay(s) {
            return String(s || '').replace(/\s*\([^)]*\)\s*/g, ' ').replace(/\s+/g, ' ').trim();
        }

        function check() {
            if (!cards.length) {
                return;
            }
            const c = cards[index];
            const val = normalizeForCompare(spellingInput.value);
            const target = normalizeForCompare(c.de);
            if (!val) {
                feedback.textContent = '';
                clearAutoNext();
                return;
            }
            attempts++;
            if (val === target) {
                const disp = stripOptionalForDisplay(c.de);
                feedback.textContent = `Correct: ${disp}`;
                feedback.className = 'mt-3 text-sm text-green-600 dark:text-green-400';
                correctCount++;
                clearAutoNext();
                autoNextTimer = setTimeout(() => {
                    next();
                }, 1000);
            } else {
                feedback.textContent = `Incorrect: ${c.de}`;
                feedback.className = 'mt-3 text-sm text-red-600 dark:text-red-400';
                mistakes.push({
                    en: c.en,
                    de: c.de
                });
                clearAutoNext();
            }
        }

        function next() {
            if (!cards.length) {
                return;
            }
            clearAutoNext();
            if (index < cards.length - 1) {
                index++;
                renderCurrent();
            } else {
                showDone();
            }
        }

        function showDone() {
            if (doneShown) return;
            doneShown = true;
            const secs = Math.max(0, Math.round((performance.now() - sessionStart) / 1000));
            const mins = Math.floor(secs / 60);
            const rem = secs % 60;
            const acc = attempts > 0 ? Math.round((correctCount / attempts) * 100) : 100;
            accValue.textContent = acc + '%';
            timeValue.textContent = mins + 'm ' + rem + 's';
            if (practiceCardEl) practiceCardEl.hidden = true;
            completeOverlay.hidden = false;
            reviewBtn.hidden = acc === 100;
            reviewBtn.disabled = mistakes.length === 0;
        }
        backBtn.addEventListener('click', () => {
            history.length > 1 ? history.back() : location.href = '/'
        });
        homeBtn.addEventListener('click', () => {
            location.href = '/'
        });
        deckSelect.addEventListener('change', e => {
            currentDeck = e.target.value;
            loadCards(currentDeck)
        });
        playAudioBtn.addEventListener('click', playAudio);
        checkBtn.addEventListener('click', check);
        nextBtn.addEventListener('click', next);
        continueBtn.addEventListener('click', () => {
            if (!currentDeck) return;
            const from = params.get('from');
            const fromParam = from ? `&from=${encodeURIComponent(from)}` : '';
            window.location.href = `/match?deck=${encodeURIComponent(currentDeck)}${fromParam}`;
        });
        reviewBtn.addEventListener('click', () => {
            if (reviewBtn.disabled) return;
            const map = new Map();
            mistakes.forEach(m => {
                const k = (m.en || '') + '|' + (m.de || '');
                if (!map.has(k)) map.set(k, m);
            });
            cards = Array.from(map.values()).map(m => ({
                en: m.en,
                de: m.de
            }));
            index = 0;
            correctCount = 0;
            attempts = 0;
            mistakes = [];
            doneShown = false;
            completeOverlay.hidden = true;
            if (practiceCardEl) practiceCardEl.hidden = false;
            renderCurrent();
        });
        spellingInput.addEventListener('keydown', e => {
            if (e.key === 'Enter') {
                e.preventDefault();
                if (e.shiftKey) {
                    next();
                } else {
                    check();
                }
            }
        });
        let tooltipOpen = false;

        function updateTooltipPosition() {
            const rect = englishWord.getBoundingClientRect();
            const h = deTooltip.offsetHeight || 28;
            deTooltip.style.left = (rect.left + rect.width / 2) + 'px';
            deTooltip.style.top = (rect.top - h - 8) + 'px';
        }

        function openTooltip(text) {
            deTooltip.textContent = text;
            deTooltip.classList.remove('hidden');
            updateTooltipPosition();
            tooltipOpen = true;
        }

        function closeTooltip() {
            deTooltip.classList.add('hidden');
            tooltipOpen = false;
        }
        englishWord.addEventListener('click', (e) => {
            e.stopPropagation();
            if (!cards.length) return;
            const c = cards[index];
            if (tooltipOpen) {
                closeTooltip();
            } else {
                openTooltip(c.de);
            }
        });
        deTooltip.addEventListener('click', (e) => {
            e.stopPropagation();
        });
        document.addEventListener('click', () => {
            if (tooltipOpen) closeTooltip();
        });
        window.addEventListener('scroll', () => {
            if (tooltipOpen) updateTooltipPosition();
        }, {
            passive: true
        });
        window.addEventListener('resize', () => {
            if (tooltipOpen) updateTooltipPosition();
        });

        function hydrateAudioFromLocalStorage() {
            cards.forEach(c => {
                const v = localStorage.getItem(`audio:de:${c.de}`);
                if (v) audioCache.set(c.de, v);
            });
        }
        async function preloadDeckAudio(name) {
            try {
                const resp = await fetch(`/preload_deck_audio?deck=${encodeURIComponent(name)}`);
                if (!resp.ok) return;
                const data = await resp.json();
                const entries = Object.entries(data && data.audio_urls ? data.audio_urls : {});
                const tasks = entries.map(([text, url]) => fetchAudioAndCache(text, url));
                await Promise.allSettled(tasks);
            } catch {}
        }
        async function fetchAudioAndCache(text, url) {
            try {
                const r = await fetch(url);
                if (!r.ok) {
                    audioCache.set(text, url);
                    return;
                }
                const blob = await r.blob();
                const objUrl = URL.createObjectURL(blob);
                audioCache.set(text, objUrl);
                audioBlobUrls.set(text, objUrl);
                const base64 = await blobToBase64(blob);
                try {
                    localStorage.setItem(`audio:de:${text}`, String(base64));
                } catch {}
            } catch {
                audioCache.set(text, url);
            }
        }

        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }

        function clearDeckAudio() {
            try {
                audioBlobUrls.forEach(u => {
                    try {
                        URL.revokeObjectURL(u);
                    } catch {}
                });
                audioBlobUrls.clear();
                audioCache.clear();
            } catch {}
        }

        function clearAutoNext() {
            if (autoNextTimer) {
                try {
                    clearTimeout(autoNextTimer);
                } catch {};
                autoNextTimer = null;
            }
        }
        loadDecks();
    </script>
</body>

</html>